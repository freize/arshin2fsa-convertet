<!DOCTYPE html>
<html lang="ru">
<head>
    <!-- Теги фавикона -->
    <!-- Standard favicon -->
    <link rel="icon" type="image/x-icon" href="/favicons/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="/favicons/favicon-48x48.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="128x128" href="/favicons/favicon-128x128.png">

    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">

    <!-- Android Chrome Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/favicons/android-chrome-512x512.png">

    <!-- Microsoft Tiles -->
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/favicons/android-chrome-192x192.png">
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">

    <!-- Web App Manifest -->
    <link rel="manifest" href="/favicons/site.webmanifest">
    <!-- Конец тегов фавикона -->
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>Конвертер данных для ФГИС ФСА</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* CSS переменные для темной и светлой темы */
        :root {
            --bg-primary: #f0f4f8;
            --bg-card: #ffffff;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --border-color: #e5e7eb;
            --accent-sky: #0ea5e9;
            --accent-emerald: #10b981;
            --grid-color: rgba(160, 174, 192, 0.15);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #0f172a;
                --bg-card: #1e293b;
                --text-primary: #f1f5f9;
                --text-secondary: #94a3b8;
                --border-color: #334155;
                --accent-sky: #38bdf8;
                --accent-emerald: #34d399;
                --grid-color: rgba(100, 116, 139, 0.15);
            }
        }

        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            background-image: linear-gradient(0deg, transparent 14px, var(--grid-color) 15px),
                              linear-gradient(90deg, transparent 14px, var(--grid-color) 15px);
            background-size: 15px 15px; 
            background-attachment: fixed;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        /* Главная карточка */
        .main-card {
            background-color: var(--bg-card);
            transition: background-color 0.3s ease;
        }

        .drag-area {
            border: 3px dashed #94a3b8; /* slate-400 */
            transition: all 0.3s ease;
        }
        .drag-area.active {
            border-color: var(--accent-sky);
            background-color: rgba(14, 165, 233, 0.05);
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.2);
        }
        
        details[open] summary svg {
            transform: rotate(180deg);
        }
        
        /* Анимация полос прогресса */
        @keyframes progress-stripes {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .animate-progress-stripes {
            width: 200%; 
            animation: progress-stripes 2s linear infinite;
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.15) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.15) 50%,
                rgba(255, 255, 255, 0.15) 75%,
                transparent 75%,
                transparent
            );
            background-size: 1rem 1rem;
            will-change: transform;
        }
        
        .snils-input:focus, .mpi-input:focus {
             outline: none;
             border-color: #f97316; /* orange-500 */
             box-shadow: 0 0 0 1px #f97316;
        }

        /* Стили для ползунков прокрутки - улучшенная версия */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-card);
            border-radius: 6px;
            margin: 2px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--accent-sky) 0%, var(--accent-emerald) 100%);
            border-radius: 6px;
            border: 2px solid var(--bg-card);
            transition: all 0.3s ease;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, var(--accent-emerald) 0%, var(--accent-sky) 100%);
            transform: scale(1.05);
        }

        ::-webkit-scrollbar-thumb:active {
            background: linear-gradient(135deg, #0c94d4 0%, #0da371 100%);
        }

        ::-webkit-scrollbar-corner {
            background: var(--bg-primary);
        }

        /* Для контейнеров с темным фоном */
        .dark ::-webkit-scrollbar-track,
        .dark::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        /* Для Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--accent-sky) var(--bg-card);
        }

        /* Темная тема для Firefox */
        @media (prefers-color-scheme: dark) {
            * {
                scrollbar-color: var(--accent-sky) var(--bg-primary);
            }
        }

        /* Кастомный класс для контейнеров с прокруткой */
        .custom-scrollbar {
            scrollbar-width: thin;
            scrollbar-color: var(--accent-sky) transparent;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
            margin: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: var(--accent-sky);
            border-radius: 6px;
            border: 2px solid transparent;
            background-clip: content-box;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: var(--accent-emerald);
            background-clip: content-box;
        }

        /* Плавная прокрутка для всего приложения */
        html {
            scroll-behavior: smooth;
        }

        /* Темная тема для различных элементов */
        @media (prefers-color-scheme: dark) {
            .drag-area {
                border-color: #475569; /* slate-600 */
            }
            
            .border-gray-200 {
                border-color: var(--border-color);
            }
            
            .bg-gray-50 {
                background-color: rgba(30, 41, 59, 0.5);
            }
            
            .bg-gray-100 {
                background-color: rgba(30, 41, 59, 0.7);
            }
            
            .text-gray-500 {
                color: var(--text-secondary);
            }
            
            .text-gray-700 {
                color: var(--text-primary);
            }
            
            .bg-sky-50 {
                background-color: rgba(56, 189, 248, 0.1);
            }
            
            .border-sky-200 {
                border-color: rgba(56, 189, 248, 0.3);
            }
            
            .text-sky-800 {
                color: #bae6fd;
            }
            
            .bg-yellow-50 {
                background-color: rgba(253, 230, 138, 0.1);
            }
            
            .border-yellow-300 {
                border-color: rgba(253, 230, 138, 0.3);
            }
            
            .text-yellow-800 {
                color: #fef3c7;
            }
            
            .bg-green-50 {
                background-color: rgba(134, 239, 172, 0.1);
            }
            
            .border-green-300 {
                border-color: rgba(134, 239, 172, 0.3);
            }
            
            .text-green-800 {
                color: #d1fae5;
            }
            
            .bg-white {
                background-color: var(--bg-card);
            }
            
            .bg-sky-100 {
                background-color: rgba(56, 189, 248, 0.2);
            }
            
            .shadow-inner {
                box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.2);
            }
            
            .bg-red-100 {
                background-color: rgba(248, 113, 113, 0.1);
            }
            
            .bg-orange-100 {
                background-color: rgba(251, 146, 60, 0.1);
            }
            
            .bg-red-50 {
                background-color: rgba(248, 113, 113, 0.05);
            }
            
            .bg-orange-50 {
                background-color: rgba(251, 146, 60, 0.05);
            }
            
            .border-red-200 {
                border-color: rgba(248, 113, 113, 0.3);
            }
            
            .border-orange-200 {
                border-color: rgba(251, 146, 60, 0.3);
            }
            
            .bg-gray-200 {
                background-color: rgba(51, 65, 85, 0.5);
            }
            
            .divide-gray-200 > :not([hidden]) ~ :not([hidden]) {
                border-color: var(--border-color);
            }
            
            .hover\:bg-gray-50:hover {
                background-color: rgba(30, 41, 59, 0.8);
            }

            /* Улучшенные стили для темной темы ползунков */
            ::-webkit-scrollbar-track {
                background: var(--bg-primary);
            }
            
            ::-webkit-scrollbar-thumb {
                border: 2px solid var(--bg-primary);
            }
            
            .custom-scrollbar {
                scrollbar-color: var(--accent-sky) var(--bg-primary);
            }
        }
        
    </style>
    <script>
        tailwind.config = {
            darkMode: 'media',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'accent-sky': '#0ea5e9', // sky-500 for primary
                        'accent-emerald': '#10b981', // emerald-500 for success
                    }
                }
            }
        }
    </script>
</head>
<body class="p-4 md:p-12">

    <!-- Главная карточка - чистая, белая, с акцентной рамкой -->
    <div class="max-w-4xl mx-auto main-card p-6 md:p-10 rounded-xl shadow-xl border-t-4 border-accent-sky">
        <header class="mb-8 border-b border-gray-200 pb-4">
            <h1 class="text-3xl font-bold text-gray-800 mb-1 dark:text-gray-100">
                <span class="text-accent-sky">|</span> Конвертер данных <span class="text-accent-sky">ФГИС</span>
            </h1>
            <p class="text-gray-500 text-base dark:text-gray-400">
                Преобразование выгрузки ФГИС "АРШИН" в формат для загрузки в ФГИС ФСА.
            </p>
        </header>

        <!-- Instruction Guide Block -->
        <details class="mb-8 p-4 bg-sky-50 border border-sky-200 rounded-lg dark:bg-sky-900/20 dark:border-sky-800">
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-sky-800 dark:text-sky-200 focus:outline-none">
                <span>
                    <svg class="w-5 h-5 inline-block mr-2 text-sky-600 dark:text-sky-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    Инструкция по подготовке файла (ВАЖНО)
                </span>
                <svg class="w-4 h-4 text-sky-600 dark:text-sky-400 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            
            <div class="mt-3 text-sm text-gray-700 dark:text-gray-300 space-y-3">
                <p class="font-bold text-sky-900 dark:text-sky-100">1. Проверка структуры файла:</p>
                <p>Ваш файл должен быть экспортирован из реестра таким образом, чтобы заголовок таблицы начинался с <span class="font-mono bg-sky-100 dark:bg-sky-900/30 p-1 rounded">3-й строки</span> (первые две строки – это метаданные, которые конвертер автоматически пропустит).</p>
                
                <p class="font-bold text-sky-900 dark:text-sky-100">2. Обязательные колонки (Индекс = номер колонки, начиная с 0):</p>
                <ul class="list-disc list-inside ml-4 space-y-1 bg-white dark:bg-slate-800 p-3 rounded border dark:border-slate-700">
                    <li><span class="font-mono">Author</span> (Индекс **1**): ФИО автора записи. **Требуется сопоставление СНИЛС.**</li>
                    <li><span class="font-mono">Type</span> (Индекс **3**): Наименование типа СИ. (Используется для тега TypeMeasuringInstrument в XML)</li>
                    <li><span class="font-mono">GRSI</span> (Индекс **4**): Номер записи в ГРСИ. **Требуется сопоставление МПИ.**</li>
                    <li><span class="font-mono">Date</span> (Индекс **5**): Дата поверки.</li>
                    <li><span class="font-mono">Suitability</span> (Индекс **9**): Пригодность ("Да" или "Нет").</li>
                    <li><span class="font-mono">Document</span> (Индекс **10**): Номер документа (протокола) поверки.</li>
                </ul>
                
                <p class="font-bold text-sky-900 dark:text-sky-100">3. Сохранение в формат CSV:</p>
                <p>В Excel выберите "Сохранить как" и выберите тип файла <span class="font-medium">CSV (разделители-запятые)</span> или <span class="font-medium">CSV (разделители-точки с запятой)</span>. Конвертер автоматически определит разделитель.</p>
                
                <p class="text-xs italic mt-4 text-sky-700 dark:text-sky-300">
                    <span class="font-semibold">Расчет МПИ:</span> Дата окончания поверки рассчитывается как (Дата Поверки + МПИ в месяцах - 1 день). Если значение МПИ равно "-", в выходном файле дата окончания устанавливается как 2100-01-01.
                </p>
            </div>
        </details>
        
        <!-- Input and Status Section -->
        <div class="space-y-6">
            
            <!-- БЛОК 1: Загрузка файла (Drag-n-Drop) -->
            <div>
                <h2 class="text-xl font-semibold text-gray-700 dark:text-gray-300 mb-3 border-b pb-1 dark:border-gray-700">
                    Загрузка исходного CSV
                </h2>
                <div id="drop-area" class="drag-area p-8 rounded-lg text-center cursor-pointer transition-all hover:ring-2 hover:ring-offset-2 hover:ring-sky-300 dark:hover:ring-sky-700">
                    <input type="file" id="fileInput" accept=".csv" class="hidden">
                    <svg class="mx-auto h-12 w-12 text-accent-sky" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 014 4v2a4 4 0 01-4 4H7z" />
                    </svg>
                    <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                        Перетащите CSV-файл сюда или <span class="text-accent-sky font-semibold">нажмите для выбора</span>
                    </p>
                    <p id="fileNameDisplay" class="text-xs text-gray-400 dark:text-gray-500 mt-1"></p>
                </div>
            </div>
            
            <!-- БЛОК ПРЕДУПРЕЖДЕНИЯ О НЕДОСТАЮЩИХ АВТОРАХ (СНИЛС) -->
            <div id="missingAuthorsContainer" class="hidden p-4 bg-red-100 border-l-4 border-red-500 rounded-lg shadow-md dark:bg-red-900/20 dark:border-red-600">
                <div class="flex items-start">
                    <svg class="h-6 w-6 text-red-600 dark:text-red-400 mt-1 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.3 16c-.77 1.333.192 3 1.732 3z" />
                    </svg>
                    <div class="ml-3 w-full">
                        <h3 class="text-lg font-semibold text-red-800 dark:text-red-200">
                            Обнаружены недостающие СНИЛС!
                        </h3>
                        <p class="mt-1 text-sm text-red-700 dark:text-red-300">
                            Введите СНИЛС для следующих авторов, чтобы не пропускать их записи.
                        </p>
                        <!-- ДИНАМИЧЕСКАЯ ФОРМА ДЛЯ БЫСТРОГО ВВОДА СНИЛС -->
                        <form id="missingSnilsForm" class="mt-2 text-sm bg-red-50 dark:bg-red-900/10 p-3 rounded max-h-56 overflow-y-auto space-y-2 custom-scrollbar">
                            <!-- Список авторов и полей ввода будет сгенерирован здесь -->
                        </form>
                        <button id="saveMissingSnilsButton" class="w-full mt-3 bg-red-600 text-white font-bold py-2 rounded-lg hover:bg-red-700 transition-colors duration-200 dark:bg-red-700 dark:hover:bg-red-600">
                            Сохранить все недостающие СНИЛС
                        </button>
                    </div>
                </div>
            </div>

            <!-- БЛОК: ПРЕДУПРЕЖДЕНИЕ О НЕДОСТАЮЩИХ МПИ (Ключ - ГРСИ) -->
            <div id="missingMpiContainer" class="hidden p-4 bg-orange-100 border-l-4 border-orange-500 rounded-lg shadow-md dark:bg-orange-900/20 dark:border-orange-600">
                <div class="flex items-start">
                    <svg class="h-6 w-6 text-orange-600 dark:text-orange-400 mt-1 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h.01M17 11h.01M9 15h.01M15 15h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" /></svg>
                    <div class="ml-3 w-full">
                        <h3 class="text-lg font-semibold text-orange-800 dark:text-orange-200">
                            Обнаружены недостающие МПИ!
                        </h3>
                        <p class="mt-1 text-sm text-orange-700 dark:text-orange-300">
                            Введите Межповерочный Интервал (в месяцах) или "-" для бессрочной поверки для следующих Номеров записи ГРСИ.
                        </p>
                        <!-- ДИНАМИЧЕСКАЯ ФОРМА ДЛЯ БЫСТРОГО ВВОДА МПИ -->
                        <form id="missingMpiForm" class="mt-2 text-sm bg-orange-50 dark:bg-orange-900/10 p-3 rounded max-h-56 overflow-y-auto space-y-2 custom-scrollbar">
                            <!-- Список типов СИ и полей ввода будет сгенерирован здесь -->
                        </form>
                        <button id="saveMissingMpiButton" class="w-full mt-3 bg-orange-600 text-white font-bold py-2 rounded-lg hover:bg-orange-700 transition-colors duration-200 dark:bg-orange-700 dark:hover:bg-orange-600">
                            Сохранить все недостающие МПИ
                        </button>
                    </div>
                </div>
            </div>

            <!-- НОВЫЙ БЛОК: ПРЕДУПРЕЖДЕНИЕ О РУЧНЫХ МПИ (по Document) -->
            <div id="manualMpiContainer" class="hidden p-4 bg-purple-100 border-l-4 border-purple-500 rounded-lg shadow-md dark:bg-purple-900/20 dark:border-purple-600">
                <div class="flex items-start">
                    <svg class="h-6 w-6 text-purple-600 dark:text-purple-400 mt-1 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                    </svg>
                    <div class="ml-3 w-full">
                        <h3 class="text-lg font-semibold text-purple-800 dark:text-purple-200">
                            Требуется ручной ввод МПИ!
                        </h3>
                        <p class="mt-1 text-sm text-purple-700 dark:text-purple-300">
                            Для следующих записей с отметкой "Вручную" требуется ввести МПИ по номеру документа (не сохраняется в базу).
                        </p>
                        <!-- ДИНАМИЧЕСКАЯ ФОРМА ДЛЯ РУЧНОГО ВВОДА МПИ ПО DOCUMENT -->
                        <form id="manualMpiForm" class="mt-2 text-sm bg-purple-50 dark:bg-purple-900/10 p-3 rounded max-h-56 overflow-y-auto space-y-3 custom-scrollbar">
                            <!-- Список документов и полей ввода будет сгенерирован здесь -->
                        </form>
                        <button id="saveManualMpiButton" class="w-full mt-3 bg-purple-600 text-white font-bold py-2 rounded-lg hover:bg-purple-700 transition-colors duration-200 dark:bg-purple-700 dark:hover:bg-purple-600">
                            Сохранить все ручные МПИ
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- НОВЫЙ БЛОК: ОПЦИЯ РАЗДЕЛЕНИЯ ФАЙЛОВ -->
            <div id="splitOutputContainer" class="p-3 bg-gray-100 dark:bg-slate-800 rounded-lg border border-gray-200 dark:border-slate-700">
                <label for="splitOutputCheckbox" class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="splitOutputCheckbox" class="h-5 w-5 text-accent-sky border-gray-300 rounded focus:ring-accent-sky dark:border-slate-600 dark:bg-slate-700">
                    <span class="text-gray-700 dark:text-gray-300 font-medium select-none">
                        Разделить выходные файлы (максимально 1000 записей на файл).
                    </span>
                </label>
            </div>


            <!-- БЛОК 2: Статус и Скачивание -->
            <div class="p-4 bg-gray-50 dark:bg-slate-800/50 rounded-lg shadow-inner border border-gray-200 dark:border-slate-700">
                <h2 class="text-xl font-semibold text-gray-700 dark:text-gray-300 mb-3 border-b pb-1 dark:border-gray-700">
                    Статус и результат
                </h2>
                
                <div id="statusMessage" class="text-gray-600 dark:text-gray-400 text-lg font-semibold mb-4">
                    Ожидание загрузки файла...
                </div>
                
                <!-- Processing Animation -->
                <div id="processingIndicator" class="mt-4 hidden">
                    <div class="h-2.5 bg-sky-200 dark:bg-sky-800 rounded-full overflow-hidden">
                        <div class="h-full bg-accent-sky rounded-full animate-progress-stripes"></div>
                    </div>
                    <p class="text-xs text-accent-sky mt-1 font-medium animate-pulse">Обработка данных...</p>
                </div>

                <!-- Кнопка с accent-emerald -->
                <button id="downloadButton"
                        class="w-full mt-4 bg-emerald-500 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:bg-emerald-600 transition-colors duration-200 opacity-50 cursor-not-allowed disabled:shadow-none dark:bg-emerald-600 dark:hover:bg-emerald-500"
                        disabled>
                    Скачать XML-файл
                </button>
                <p id="recordCount" class="text-sm text-gray-500 dark:text-gray-400 mt-2 text-center hidden"></p>
            </div>
        </div>
        
        <!-- БЛОК 3: Управление сопоставлением Авторов и СНИЛС -->
        <details class="mt-8 p-4 bg-yellow-50 border border-yellow-300 rounded-lg dark:bg-yellow-900/20 dark:border-yellow-700" open>
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-yellow-800 dark:text-yellow-200 focus:outline-none">
                <span>
                    <svg class="w-5 h-5 inline-block mr-2 text-yellow-600 dark:text-yellow-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" /></svg>
                    Управление сотрудниками и СНИЛС.
                </span>
                <svg class="w-4 h-4 text-yellow-600 dark:text-yellow-400 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            
            <div class="mt-4 space-y-4">
                <form id="snilsMappingForm" class="flex flex-col sm:flex-row gap-2">
                    <input type="text" id="authorNameInput" placeholder="ФИО автора (как в CSV)" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-yellow-500 focus:border-yellow-500 text-sm dark:bg-slate-700 dark:border-slate-600 dark:text-white" autocomplete="off">
                    <input type="text" id="snilsInput" placeholder="СНИЛС (11 цифр)" pattern="^\d{11}$" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-yellow-500 focus:border-yellow-500 text-sm dark:bg-slate-700 dark:border-slate-600 dark:text-white" autocomplete="off">
                    <button type="submit" class="bg-yellow-600 text-white p-2 rounded-lg font-medium hover:bg-yellow-700 transition duration-150 flex-shrink-0 dark:bg-yellow-700 dark:hover:bg-yellow-600">
                        Добавить/Обновить
                    </button>
                </form>

                <!-- Добавлены кнопки Импорта/Экспорта СНИЛС -->
                <div class="flex gap-2">
                    <button id="exportSnilsButton" type="button" class="w-1/2 bg-gray-300 text-gray-800 p-2 rounded-lg font-medium hover:bg-gray-400 transition duration-150 dark:bg-slate-600 dark:text-slate-200 dark:hover:bg-slate-500">
                        Экспорт JSON
                    </button>
                    <input type="file" id="importSnilsFile" accept=".json" class="hidden">
                    <button id="importSnilsButton" type="button" class="w-1/2 bg-gray-300 text-gray-800 p-2 rounded-lg font-medium hover:bg-gray-400 transition duration-150 dark:bg-slate-600 dark:text-slate-200 dark:hover:bg-slate-500">
                        Импорт JSON
                    </button>
                </div>
                
                <div id="mappingListContainer" class="max-h-60 overflow-y-auto border border-gray-300 rounded-lg shadow-inner dark:border-slate-600 custom-scrollbar">
                    <!-- Mappings will be rendered here -->
                    <p class="p-4 text-gray-500 dark:text-gray-400 text-sm italic" id="emptyMappingMessage">
                        Нет сохраненных сопоставлений. Используйте форму выше или импортируйте JSON.
                    </p>
                </div>
            </div>
        </details>
        
        <!-- БЛОК 4: Управление сопоставлением ГРСИ и МПИ (Ключ - ГРСИ) -->
        <details class="mt-4 p-4 bg-green-50 border border-green-300 rounded-lg dark:bg-green-900/20 dark:border-green-700" open>
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-green-800 dark:text-green-200 focus:outline-none">
                <span>
                    <svg class="w-5 h-5 inline-block mr-2 text-green-600 dark:text-green-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    Управление ГРСИ и МПИ.
                </span>
                <svg class="w-4 h-4 text-green-600 dark:text-green-400 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            
            <div class="mt-4 space-y-4">
                <form id="mpiMappingForm" class="flex flex-col sm:flex-row gap-2">
                    <input type="text" id="instrumentTypeInput" placeholder="Номер записи ГРСИ (как в CSV, колонка 4)" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-green-500 focus:border-green-500 text-sm dark:bg-slate-700 dark:border-slate-600 dark:text-white" autocomplete="off">
                    <input type="text" id="mpiMonthsConfigInput" placeholder="МПИ (мес., напр. 12, 24 или -)" pattern="^[0-9]+$|^-$" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-green-500 focus:border-green-500 text-sm dark:bg-slate-700 dark:border-slate-600 dark:text-white" autocomplete="off">
                    <div class="flex items-center space-x-2">
                        <input type="checkbox" id="manualCheckbox" class="h-4 w-4 text-green-600 border-gray-300 rounded focus:ring-green-500 dark:border-slate-600 dark:bg-slate-700">
                        <label for="manualCheckbox" class="text-sm text-gray-700 dark:text-gray-300 whitespace-nowrap">Вручную</label>
                    </div>
                    <button type="submit" class="bg-green-600 text-white p-2 rounded-lg font-medium hover:bg-green-700 transition duration-150 flex-shrink-0 dark:bg-green-700 dark:hover:bg-green-600">
                        Добавить/Обновить
                    </button>
                </form>
                
                <!-- Добавлены кнопки Импорта/Экспорта МПИ -->
                <div class="flex gap-2">
                    <button id="exportMpiButton" type="button" class="w-1/2 bg-gray-300 text-gray-800 p-2 rounded-lg font-medium hover:bg-gray-400 transition duration-150 dark:bg-slate-600 dark:text-slate-200 dark:hover:bg-slate-500">
                        Экспорт JSON
                    </button>
                    <input type="file" id="importMpiFile" accept=".json" class="hidden">
                    <button id="importMpiButton" type="button" class="w-1/2 bg-gray-300 text-gray-800 p-2 rounded-lg font-medium hover:bg-gray-400 transition duration-150 dark:bg-slate-600 dark:text-slate-200 dark:hover:bg-slate-500">
                        Импорт JSON
                    </button>
                </div>

                <div id="mpiMappingListContainer" class="max-h-60 overflow-y-auto border border-gray-300 rounded-lg shadow-inner dark:border-slate-600 custom-scrollbar">
                    <!-- Mappings will be rendered here -->
                    <p class="p-4 text-gray-500 dark:text-gray-400 text-sm italic" id="emptyMpiMessage">
                        Нет сохраненных интервалов МПИ. Используйте форму выше или импортируйте JSON.
                    </p>
                </div>
                <!-- Аккуратная навигационная ссылка -->
                <div class="mb-4 -mt-2"> 
                    <a href="/mpi.html" class="text-sm text-gray-500 hover:text-blue-600 transition duration-150 flex items-center font-medium dark:text-gray-400 dark:hover:text-blue-400">
                    <!-- Иконка стрелки влево для навигации -->
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                    К конвертеру ГРСИ и МПИ
                </a>
                </div>
            </div>
        </details>

        <!-- Debug Log Spoiler (Контейнер лога) -->
        <details class="mt-8 p-4 bg-gray-100 border border-gray-300 rounded-lg dark:bg-slate-800 dark:border-slate-700" id="debugLogSpoiler">
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-gray-700 dark:text-gray-300 focus:outline-none">
                <span>
                    <!-- Новая иконка: Документ/Список -->
                    <svg class="w-5 h-5 inline-block mr-2 text-gray-500 dark:text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2m-9 0V3a1 1 0 011-1h4a1 1 0 011 1v2M9 5h6m-6 4h6m-6 4h6m-6 4h6" />
                    </svg>
                    Лог конвертации
                </span>
                <svg class="w-4 h-4 text-gray-500 dark:text-gray-400 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            <!-- Контейнер лога: p-2 для минимального, но достаточного отступа -->
            <div id="logDetails" class="mt-2 text-sm text-gray-700 dark:text-gray-300 overflow-auto h-40 bg-white dark:bg-slate-900 p-2 rounded-lg border border-gray-200 dark:border-slate-600 shadow-inner custom-scrollbar">
                <!-- Log entries will appear here as structured HTML -->
            </div>
        </details>

        <!-- Footer Section with Copyright -->
        <footer class="mt-10 pt-6 border-t border-gray-200 dark:border-slate-700 text-center">
            <p class="text-xs text-gray-400 dark:text-gray-500">
                Разработано Службой испытаний, экспертизы и метрологии ГАУ ИНПЦ "Гормедтехника".
            </p>
        </footer>
    </div>

    <script>
        // --- КОНФИГУРАЦИЯ ---
        const SNILS_STORAGE_KEY = 'fgis_fsa_author_snils_map'; 
        const MPI_STORAGE_KEY = 'fgis_fsa_mpi_map_grsi'; 
        const HEADER_SKIP_LINES = 2; 
        const MIN_PROCESSING_TIME = 1500; 
        const MAX_RECORDS_PER_FILE = 1000; // НОВАЯ КОНСТАНТА: Максимальное количество записей на файл
        const MPI_NO_EXPIRY_MARK = '-'; // Значение МПИ, обозначающее бессрочную поверку
        const MPI_NO_EXPIRY_DATE = '2100-01-01'; // Дата окончания поверки для бессрочного МПИ

        const COL_INDEX = {
            'Author': 1,
            'Type': 3,      
            'GRSI': 4,      
            'Date': 5,
            'Suitability': 9,
            'Document': 10
        };

        // --- ГЛОБАЛЬНЫЕ ХРАНИЛИЩА ---
        let errorCount = 0;
        let authorSnilsMap = {}; 
        let mpiMonthsMap = {};  // Теперь хранит объекты: {value: мпи, manual: boolean}
        
        let lastCsvContent = null;
        let lastDelimiter = null;
        let lastFileNameBase = null; // Базовое имя файла без индекса
        let allProcessedRecords = []; // Хранение всех валидных записей для скачивания
        let manualMpiTempStorage = {}; // Временное хранилище для ручных МПИ по Document (не сохраняется в localStorage)

        // --- ЭЛЕМЕНТЫ DOM ---
        const fileInput = document.getElementById('fileInput');
        const dropArea = document.getElementById('drop-area');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const statusMessage = document.getElementById('statusMessage');
        const downloadButton = document.getElementById('downloadButton');
        const recordCountElement = document.getElementById('recordCount');
        const processingIndicator = document.getElementById('processingIndicator');
        const debugLogSpoiler = document.getElementById('debugLogSpoiler');
        const logDetails = document.getElementById('logDetails');
        
        // НОВЫЙ ЭЛЕМЕНТ
        const splitOutputCheckbox = document.getElementById('splitOutputCheckbox');

        // Элементы для СНИЛС
        const snilsMappingForm = document.getElementById('snilsMappingForm');
        const authorNameInput = document.getElementById('authorNameInput');
        const snilsInput = document.getElementById('snilsInput');
        const mappingListContainer = document.getElementById('mappingListContainer');
        const emptyMappingMessage = document.getElementById('emptyMappingMessage');
        const missingAuthorsContainer = document.getElementById('missingAuthorsContainer');
        const missingSnilsForm = document.getElementById('missingSnilsForm');
        const saveMissingSnilsButton = document.getElementById('saveMissingSnilsButton');

        // Элементы для JSON I/O (СНИЛС)
        const exportSnilsButton = document.getElementById('exportSnilsButton');
        const importSnilsButton = document.getElementById('importSnilsButton');
        const importSnilsFile = document.getElementById('importSnilsFile');

        // Элементы для МПИ
        const mpiMappingForm = document.getElementById('mpiMappingForm');
        const instrumentTypeInput = document.getElementById('instrumentTypeInput'); 
        const mpiMonthsConfigInput = document.getElementById('mpiMonthsConfigInput');
        const manualCheckbox = document.getElementById('manualCheckbox');
        const mpiMappingListContainer = document.getElementById('mpiMappingListContainer');
        const emptyMpiMessage = document.getElementById('emptyMpiMessage');
        const missingMpiContainer = document.getElementById('missingMpiContainer');
        const missingMpiForm = document.getElementById('missingMpiForm');
        const saveMissingMpiButton = document.getElementById('saveMissingMpiButton');
        
        // Элементы для JSON I/O (МПИ)
        const exportMpiButton = document.getElementById('exportMpiButton');
        const importMpiButton = document.getElementById('importMpiButton');
        const importMpiFile = document.getElementById('importMpiFile');

        // Элементы для ручного ввода МПИ
        const manualMpiContainer = document.getElementById('manualMpiContainer');
        const manualMpiForm = document.getElementById('manualMpiForm');
        const saveManualMpiButton = document.getElementById('saveManualMpiButton');

        // --- УТИЛИТЫ И ОБЩИЕ ФУНКЦИИ ---

        function startProcessing(isNewFile = false) {
            logDetails.innerHTML = ''; 
            errorCount = 0;
            allProcessedRecords = []; // Очистка записей
            
            // Очищаем временное хранилище только при загрузке нового файла
            if (isNewFile) {
                manualMpiTempStorage = {}; 
            }
            
            statusMessage.textContent = 'Начало обработки файла...';
            statusMessage.classList.remove('text-red-600');
            statusMessage.classList.add('text-gray-600', 'dark:text-gray-400');
            processingIndicator.classList.remove('hidden');
            downloadButton.disabled = true;
            downloadButton.classList.add('opacity-50', 'cursor-not-allowed', 'disabled:shadow-none');
            downloadButton.classList.remove('bg-emerald-500', 'hover:bg-emerald-600', 'dark:bg-emerald-600', 'dark:hover:bg-emerald-500');
            recordCountElement.classList.add('hidden');
            missingAuthorsContainer.classList.add('hidden'); 
            missingMpiContainer.classList.add('hidden');
            manualMpiContainer.classList.add('hidden');
        }

        function stopProcessing() {
            processingIndicator.classList.add('hidden');
            if (errorCount > 0) {
                 debugLogSpoiler.open = true; 
            }
        }

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.className = `font-semibold text-lg mb-4 ${isError ? 'text-red-600 dark:text-red-400' : 'text-gray-600 dark:text-gray-400'}`;
            if (isError) {
                downloadButton.disabled = true;
                downloadButton.classList.add('opacity-50', 'cursor-not-allowed', 'disabled:shadow-none');
                downloadButton.classList.remove('bg-emerald-500', 'hover:bg-emerald-600', 'dark:bg-emerald-600', 'dark:hover:bg-emerald-500');
            }
        }

        function updateSuccess(count) {
            let message = 'Конвертация успешно завершена. Файл готов к скачиванию.';
            if (splitOutputCheckbox.checked && count > 0) {
                const numFiles = Math.ceil(count / MAX_RECORDS_PER_FILE);
                message = `Конвертация завершена. Будет загружено ${numFiles} файлов (по ${MAX_RECORDS_PER_FILE} записей).`;
            }

            updateStatus(message, false);
            downloadButton.disabled = false;
            downloadButton.classList.remove('opacity-50', 'cursor-not-allowed', 'disabled:shadow-none');
            downloadButton.classList.add('bg-emerald-500', 'hover:bg-emerald-600', 'dark:bg-emerald-600', 'dark:hover:bg-emerald-500');
            recordCountElement.textContent = `Сконвертировано валидных записей: ${count}. Ошибок обработки строк: ${errorCount}.`;
            recordCountElement.classList.remove('hidden');
        }
        
        function logMessage(message, level = 'INFO') {
            const timestamp = new Date().toLocaleTimeString('ru-RU');
            
            let iconSvg = '';
            let textColor = 'text-gray-700 dark:text-gray-300';
            let levelColor = 'text-emerald-600 dark:text-emerald-400'; 
            let levelDisplay = 'ИНФО';

            if (level === 'ERROR') {
                iconSvg = '<svg class="w-4 h-4 mr-1 flex-shrink-0 text-red-600 dark:text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.3 16c-.77 1.333.192 3 1.732 3z" /></svg>';
                textColor = 'text-red-700 dark:text-red-300';
                levelColor = 'text-red-600 dark:text-red-400';
                levelDisplay = 'ОШИБКА';
            } else if (level === 'WARN') {
                iconSvg = '<svg class="w-4 h-4 mr-1 flex-shrink-0 text-orange-600 dark:text-orange-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.3 16c-.77 1.333.192 3 1.732 3z" /></svg>';
                textColor = 'text-orange-700 dark:text-orange-300';
                levelColor = 'text-orange-600 dark:text-orange-400';
                levelDisplay = 'ПРЕДУПРЕЖДЕНИЕ';
            } else {
                iconSvg = '<svg class="w-4 h-4 mr-1 flex-shrink-0 text-emerald-600 dark:text-emerald-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>';
            }

            const logEntryHtml = `
                <div class="flex items-start text-xs font-mono py-0 leading-snug">
                    ${iconSvg}
                    <span class="${levelColor} font-bold flex-shrink-0">[${timestamp}] [${levelDisplay}]:&nbsp;</span><span class="${textColor} break-words min-w-0 flex-1">${message}</span>
                </div>
            `;
            
            logDetails.innerHTML += logEntryHtml;
            logDetails.scrollTop = logDetails.scrollHeight; 
        }

        function logError(message) {
            logMessage(message, 'ERROR');
            errorCount++;
        }
        
        function hasEncodingIssues(text) {
            return text.includes('\uFFFD');
        }

        function detectDelimiter(headerLine) {
            if (!headerLine) return ',';
            const commaCount = (headerLine.match(/,/g) || []).length;
            const semicolonCount = (headerLine.match(/;/g) || []).length;

            if (semicolonCount > commaCount + 2) {
                return ';';
            }
            return ',';
        }

        function parseDate(dateStr) {
            const formats = ["YYYY-MM-DD", "DD.MM.YYYY", "DD-MM-YYYY"];
            const cleanDateStr = dateStr.trim().split(' ')[0];

            for (const format of formats) {
                const parts = cleanDateStr.match(/(\d+)/g); 
                
                if (parts && parts.length === 3) {
                    let year, month, day;

                    if (format === "YYYY-MM-DD") {
                        [year, month, day] = parts.map(Number);
                    } else { 
                        [day, month, year] = parts.map(Number);
                    }

                    // Используем T00:00:00, чтобы избежать проблем с часовыми поясами
                    const dateObj = new Date(year, month - 1, day);

                    if (dateObj.getFullYear() === year && dateObj.getMonth() === month - 1 && dateObj.getDate() === day) {
                        return dateObj;
                    }
                }
            }
            return null; 
        }

        function formatDateToISO(dateStr) {
            const dt = parseDate(dateStr);
            if (!dt) return ""; 

            const y = dt.getFullYear();
            const m = String(dt.getMonth() + 1).padStart(2, '0');
            const d = String(dt.getDate()).padStart(2, '0');
            
            return `${y}-${m}-${d}`;
        }

        function isNoExpiryMpi(mpiValue) {
            return typeof mpiValue === 'string' && mpiValue.trim() === MPI_NO_EXPIRY_MARK;
        }

        /**
         * Функция расчета даты окончания поверки
         */
        function calculateDateEndVerification(dateVerificationStr, mpiMonths) {
            if (isNoExpiryMpi(mpiMonths)) {
                return MPI_NO_EXPIRY_DATE;
            }
            const dtStart = parseDate(dateVerificationStr);
            
            if (!dtStart) return ""; 

            const months = parseInt(mpiMonths, 10);
            if (isNaN(months) || months <= 0) {
                return "";
            }

            // Создаем копию даты для расчетов. Добавляем T00:00:00, чтобы сохранить локальную дату.
            const mpiDate = new Date(dtStart.getFullYear(), dtStart.getMonth(), dtStart.getDate());
            
            // 1. Добавляем количество месяцев МПИ
            mpiDate.setMonth(mpiDate.getMonth() + months);

            // 2. Вычитаем 1 день
            mpiDate.setDate(mpiDate.getDate() - 1);

            const y = mpiDate.getFullYear();
            const m = String(mpiDate.getMonth() + 1).padStart(2, '0');
            const d = String(mpiDate.getDate()).padStart(2, '0');
            
            return `${y}-${m}-${d}`;
        }
        
        function mapSuitability(suitabilityText) {
            const text = suitabilityText.trim().toLowerCase();
            if (text === "да" || text === "yes" || text === "пригоден") {
                return '1';
            }
            if (text === "нет" || text === "no" || text === "не пригоден") {
                return '2';
            }
            logMessage(`Не удалось определить пригодность для текста: "${suitabilityText}". Установлено значение по умолчанию: "Да" (1).`, 'WARN');
            return '1'; 
        }

        function generateFileNameBase() {
            const now = new Date();
            const y = String(now.getFullYear());
            const m = String(now.getMonth() + 1).padStart(2, '0');
            const d = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const mm = String(now.getMinutes()).padStart(2, '0');
            
            return `${y}${m}${d}_${hh}${mm}_fgis`;
        }
        
        function parseCsvLine(line, delimiter) {
            if (!line.trim()) return [];
            
            const fields = [];
            let currentField = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === delimiter && !inQuotes) {
                    fields.push(currentField.trim().replace(/^"|"$/g, ''));
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            fields.push(currentField.trim().replace(/^"|"$/g, ''));

            while (fields.length > 0 && fields[fields.length - 1] === '') {
                fields.pop();
            }
            return fields;
        }
        
        // General JSON download utility
        function downloadJSON(data, filename) {
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename; 
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logMessage(`JSON-файл "${filename}" создан и загружен.`);
        }


        // --- ЛОГИКА СОПОСТАВЛЕНИЙ ---

        function loadMappings() {
            try {
                const storedSnils = localStorage.getItem(SNILS_STORAGE_KEY);
                if (storedSnils) {
                    authorSnilsMap = JSON.parse(storedSnils);
                    logMessage('Сопоставления СНИЛС загружены.');
                }
                const storedMpi = localStorage.getItem(MPI_STORAGE_KEY);
                 if (storedMpi) {
                    mpiMonthsMap = JSON.parse(storedMpi);
                    // Конвертируем старый формат (если это просто значение) в новый формат
                    for (const grsi in mpiMonthsMap) {
                        if (typeof mpiMonthsMap[grsi] !== 'object') {
                            mpiMonthsMap[grsi] = {
                                value: mpiMonthsMap[grsi],
                                manual: false
                            };
                        }
                    }
                    logMessage('Сопоставления МПИ (ГРСИ) загружены.');
                }
            } catch(e) {
                logError(`Ошибка загрузки сопоставлений из localStorage: ${e.message}`);
                authorSnilsMap = {};
                mpiMonthsMap = {};
            }
            renderMappings();
            renderMpiMappings();
        }

        function saveAndRenderMappings() {
            try {
                localStorage.setItem(SNILS_STORAGE_KEY, JSON.stringify(authorSnilsMap));
                logMessage('Сопоставления СНИЛС сохранены.');
            } catch(e) {
                logError(`Ошибка сохранения сопоставлений СНИЛС: ${e.message}`);
            }
            renderMappings();
        }
        
        function saveAndRenderMpiMappings() {
            try {
                localStorage.setItem(MPI_STORAGE_KEY, JSON.stringify(mpiMonthsMap));
                logMessage('Сопоставления МПИ (ГРСИ) сохранены.');
            } catch(e) {
                logError(`Ошибка сохранения сопоставлений МПИ: ${e.message}`);
            }
            renderMpiMappings();
        }
        
        function renderMappings() {
            const authors = Object.keys(authorSnilsMap).sort();
            mappingListContainer.innerHTML = ''; 
            
            if (authors.length === 0) {
                mappingListContainer.appendChild(emptyMappingMessage);
                emptyMappingMessage.classList.remove('hidden');
                return;
            }

            emptyMappingMessage.classList.add('hidden');

            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-gray-200 dark:divide-gray-700';
            table.innerHTML = `
                <thead class="bg-gray-200 dark:bg-gray-700 sticky top-0">
                    <tr>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">ФИО</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">СНИЛС</th>
                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Действие</th>
                    </tr>
                </thead>
                <tbody class="bg-white dark:bg-slate-800 divide-y divide-gray-100 dark:divide-gray-700" id="mappingTableBody">
                </tbody>
            `;
            mappingListContainer.appendChild(table);
            const tbody = document.getElementById('mappingTableBody');

            authors.forEach(author => {
                const snils = authorSnilsMap[author];
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50 dark:hover:bg-slate-700 transition duration-100';
                tr.innerHTML = `
                    <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-gray-100">${author}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">${snils}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-right text-sm font-medium">
                        <button data-author="${author}" class="delete-snils-btn text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300 transition duration-150">
                            Удалить
                        </button>
                    </td>
                `;
                tbody.appendChild(tr);
            });

            tbody.querySelectorAll('.delete-snils-btn').forEach(button => {
                button.addEventListener('click', handleDeleteMapping);
            });
        }
        
        function renderMpiMappings() {
            const grsiNumbers = Object.keys(mpiMonthsMap).sort();
            mpiMappingListContainer.innerHTML = ''; 
            
            if (grsiNumbers.length === 0) {
                mpiMappingListContainer.appendChild(emptyMpiMessage);
                emptyMpiMessage.classList.remove('hidden');
                return;
            }

            emptyMpiMessage.classList.add('hidden');

            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-gray-200 dark:divide-gray-700';
            table.innerHTML = `
                <thead class="bg-gray-200 dark:bg-gray-700 sticky top-0">
                    <tr>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Номер ГРСИ</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">МПИ</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Тип</th>
                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Действие</th>
                    </tr>
                </thead>
                <tbody class="bg-white dark:bg-slate-800 divide-y divide-gray-100 dark:divide-gray-700" id="mpiMappingTableBody">
                </tbody>
            `;
            mpiMappingListContainer.appendChild(table);
            const tbody = document.getElementById('mpiMappingTableBody');

            grsiNumbers.forEach(grsi => {
                const config = mpiMonthsMap[grsi];
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50 dark:hover:bg-slate-700 transition duration-100';
                tr.innerHTML = `
                    <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-gray-100">${grsi}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                        ${config.manual ? '<span class="text-purple-600 dark:text-purple-400 font-medium">Вручную</span>' : config.value}
                    </td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                        ${config.manual ? '<span class="px-2 py-1 bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-300 rounded text-xs">Ручной</span>' : '<span class="px-2 py-1 bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300 rounded text-xs">Авто</span>'}
                    </td>
                    <td class="px-4 py-2 whitespace-nowrap text-right text-sm font-medium">
                        <button data-type="${grsi}" class="delete-mpi-btn text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300 transition duration-150">
                            Удалить
                        </button>
                    </td>
                `;
                tbody.appendChild(tr);
            });

            tbody.querySelectorAll('.delete-mpi-btn').forEach(button => {
                button.addEventListener('click', handleDeleteMpiMapping);
            });
        }

        function handleMappingForm(e) {
            e.preventDefault();
            const author = authorNameInput.value.trim();
            const snils = snilsInput.value.trim();

            if (author && snils.match(/^\d{11}$/)) {
                authorSnilsMap[author] = snils;
                logMessage(`СНИЛС сопоставление добавлено/обновлено: ${author} -> ${snils}`);
                saveAndRenderMappings();
                authorNameInput.value = '';
                snilsInput.value = '';
            } else {
                 logError('Ошибка: Проверьте правильность ФИО автора и СНИЛС (11 цифр).');
            }
        }
        
        function handleMpiMappingForm(e) {
            e.preventDefault();
            const grsiNumber = instrumentTypeInput.value.trim(); // Номер ГРСИ
            const mpiRaw = mpiMonthsConfigInput.value.trim();
            const isManual = manualCheckbox.checked;

            if (!grsiNumber) {
                logError('Ошибка: Введите номер ГРСИ.');
                return;
            }

            if (isManual) {
                // Для ручного ввода - сохраняем только флаг, без значения
                mpiMonthsMap[grsiNumber] = {
                    value: null,
                    manual: true
                };
                logMessage(`Добавлена запись ГРСИ №${grsiNumber} с ручным вводом МПИ.`);
            } else {
                // Для обычной записи - проверяем и сохраняем значение
                const isNoExpiry = mpiRaw === MPI_NO_EXPIRY_MARK;
                const mpiInt = parseInt(mpiRaw, 10);

                if (isNoExpiry || (!isNaN(mpiInt) && mpiInt > 0)) {
                    const mpiValue = isNoExpiry ? MPI_NO_EXPIRY_MARK : mpiInt;
                    const mpiText = isNoExpiry ? `бессрочный ("${MPI_NO_EXPIRY_MARK}")` : `${mpiInt} мес.`;
                    mpiMonthsMap[grsiNumber] = {
                        value: mpiValue,
                        manual: false
                    };
                    logMessage(`МПИ сопоставление добавлено/обновлено: ГРСИ №${grsiNumber} -> ${mpiText}`);
                } else {
                    logError(`Ошибка: Проверьте правильность МПИ (целое число месяцев > 0 или "${MPI_NO_EXPIRY_MARK}").`);
                    return;
                }
            }

            saveAndRenderMpiMappings();
            instrumentTypeInput.value = '';
            mpiMonthsConfigInput.value = '';
            manualCheckbox.checked = false;
        }

        function handleDeleteMapping(e) {
            const author = e.target.dataset.author;
            if (author in authorSnilsMap) {
                delete authorSnilsMap[author];
                logMessage(`Сопоставление СНИЛС удалено для автора: ${author}`);
                saveAndRenderMappings();
            }
        }
        
        function handleDeleteMpiMapping(e) {
            const grsi = e.target.dataset.type; // data-type содержит номер ГРСИ
            if (grsi in mpiMonthsMap) {
                delete mpiMonthsMap[grsi];
                logMessage(`Сопоставление МПИ удалено для ГРСИ №: ${grsi}`);
                saveAndRenderMpiMappings();
            }
        }
        
        function exportSnilsMap() {
            if (Object.keys(authorSnilsMap).length === 0) {
                logError('Нечего экспортировать: Сопоставления СНИЛС пусты.');
                return;
            }
            const filename = `snils_map_export_${new Date().toISOString().slice(0, 10)}.json`;
            downloadJSON(authorSnilsMap, filename);
        }
        
        function importSnilsMapHandler(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedMap = JSON.parse(e.target.result);
                    if (typeof importedMap !== 'object' || Array.isArray(importedMap)) {
                        logError('Ошибка импорта СНИЛС: Файл имеет неверный формат (ожидается объект {author: snils}).');
                        return;
                    }
                    
                    let newCount = 0;
                    let totalCount = 0;
                    for (const key in importedMap) {
                        if (importedMap.hasOwnProperty(key)) {
                            const snils = String(importedMap[key]).trim();
                            if (snils.match(/^\d{11}$/)) {
                                if (authorSnilsMap[key] !== snils) {
                                     newCount++;
                                }
                                authorSnilsMap[key] = snils;
                                totalCount++;
                            } else {
                                logError(`Импорт СНИЛС: Пропущено невалидное значение для ключа "${key}".`);
                            }
                        }
                    }
                    if (totalCount > 0) {
                        saveAndRenderMappings();
                        logMessage(`Успешно импортировано ${totalCount} записей СНИЛС. Новых/обновленных: ${newCount}.`);
                    } else {
                         logError('Ошибка импорта СНИЛС: В файле не найдено валидных записей.');
                    }

                } catch (error) {
                    logError(`Ошибка разбора JSON при импорте СНИЛС: ${error.message}`);
                }
            };
            reader.onerror = () => logError('Ошибка чтения файла при импорте СНИЛС.');
            reader.readAsText(file);
        }
        
        function exportMpiMap() {
            if (Object.keys(mpiMonthsMap).length === 0) {
                logError('Нечего экспортировать: Сопоставления МПИ пусты.');
                return;
            }
            const filename = `mpi_map_export_${new Date().toISOString().slice(0, 10)}.json`;
            downloadJSON(mpiMonthsMap, filename);
        }
        
        function importMpiMapHandler(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedMap = JSON.parse(e.target.result);
                    if (typeof importedMap !== 'object' || Array.isArray(importedMap)) {
                        logError('Ошибка импорта МПИ: Файл имеет неверный формат (ожидается объект {grsi_number: {value, manual}}).');
                        return;
                    }

                    let newCount = 0;
                    let totalCount = 0;
                    for (const key in importedMap) {
                        if (importedMap.hasOwnProperty(key)) {
                            const config = importedMap[key];
                            
                            // Проверяем формат конфигурации
                            if (typeof config === 'object' && config !== null) {
                                // Новый формат с объектом
                                if (config.manual === true) {
                                    // Ручная запись
                                    mpiMonthsMap[key] = { value: null, manual: true };
                                    totalCount++;
                                    if (!mpiMonthsMap[key] || mpiMonthsMap[key].manual !== true) {
                                        newCount++;
                                    }
                                } else if (config.value !== undefined) {
                                    // Обычная запись с значением
                                    const mpiString = typeof config.value === 'string' ? config.value.trim() : config.value;
                                    const isNoExpiry = mpiString === MPI_NO_EXPIRY_MARK;
                                    const mpi = parseInt(mpiString, 10);
                                    
                                    if (isNoExpiry || (!isNaN(mpi) && mpi > 0)) {
                                        mpiMonthsMap[key] = { 
                                            value: isNoExpiry ? MPI_NO_EXPIRY_MARK : mpi, 
                                            manual: false 
                                        };
                                        totalCount++;
                                        if (!mpiMonthsMap[key] || mpiMonthsMap[key].value !== mpiMonthsMap[key].value) {
                                            newCount++;
                                        }
                                    } else {
                                        logError(`Импорт МПИ: Пропущено невалидное значение МПИ для ГРСИ №"${key}".`);
                                    }
                                }
                            } else if (typeof config === 'string' || typeof config === 'number') {
                                // Старый формат - только значение
                                const mpiString = String(config);
                                const isNoExpiry = mpiString === MPI_NO_EXPIRY_MARK;
                                const mpi = parseInt(mpiString, 10);
                                
                                if (isNoExpiry || (!isNaN(mpi) && mpi > 0)) {
                                    mpiMonthsMap[key] = { 
                                        value: isNoExpiry ? MPI_NO_EXPIRY_MARK : mpi, 
                                        manual: false 
                                    };
                                    totalCount++;
                                    newCount++;
                                } else {
                                    logError(`Импорт МПИ: Пропущено невалидное значение МПИ для ГРСИ №"${key}".`);
                                }
                            }
                        }
                    }
                    
                    if (totalCount > 0) {
                        saveAndRenderMpiMappings();
                        logMessage(`Успешно импортировано ${totalCount} записей МПИ. Новых/обновленных: ${newCount}.`);
                    } else {
                         logError('Ошибка импорта МПИ: В файле не найдено валидных записей.');
                    }
                    
                } catch (error) {
                    logError(`Ошибка разбора JSON при импорте МПИ: ${error.message}`);
                }
            };
            reader.onerror = () => logError('Ошибка чтения файла при импорте МПИ.');
            reader.readAsText(file);
        }

        
        function getUniqueValuesFromCsv(csvContent, delimiter, colIndex) {
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            if (lines.length <= HEADER_SKIP_LINES + 1) return new Set();

            const dataLines = lines.slice(HEADER_SKIP_LINES + 1);
            const uniqueValues = new Set();
            
            dataLines.forEach((line) => {
                const fields = parseCsvLine(line, delimiter);
                if (fields.length > colIndex) {
                    const value = fields[colIndex].trim();
                    if (value) uniqueValues.add(value);
                }
            });
            return uniqueValues;
        }

        function checkAndDisplayMissingAuthors(uniqueAuthors) {
            const missingAuthors = [];
            uniqueAuthors.forEach(author => {
                if (!(author in authorSnilsMap)) {
                    missingAuthors.push(author);
                }
            });

            if (missingAuthors.length > 0) {
                missingAuthorsContainer.classList.remove('hidden');
                logError(`Обнаружено ${missingAuthors.length} уникальных авторов без сопоставления СНИЛС.`);
                
                missingSnilsForm.innerHTML = ''; 
                missingAuthors.forEach(author => {
                    const div = document.createElement('div');
                    div.className = 'flex flex-col sm:flex-row items-center gap-2 bg-white dark:bg-slate-800 p-2 rounded shadow-sm border border-red-200 dark:border-red-800';
                    div.innerHTML = `
                        <span class="font-medium text-gray-800 dark:text-gray-200 text-sm w-full sm:w-2/5 truncate" title="${author}">${author}</span>
                        <input type="text" data-author="${author}" placeholder="СНИЛС (11 цифр)" pattern="^\\d{11}$"
                               class="snils-input flex-1 p-1 border border-gray-300 dark:border-slate-600 dark:bg-slate-700 dark:text-white rounded text-sm w-full" autocomplete="off">
                    `;
                    missingSnilsForm.appendChild(div);
                });
                saveMissingSnilsButton.onclick = handleMissingSnilsSubmission;
                return true; 
            } else {
                missingAuthorsContainer.classList.add('hidden');
                logMessage('Все авторы из файла успешно сопоставлены с данными СНИЛС.');
                return false;
            }
        }
        
        function checkAndDisplayMissingMpi(csvContent, usedDelimiter) {
            const uniqueGrsiNumbers = getUniqueValuesFromCsv(csvContent, usedDelimiter, COL_INDEX.GRSI);
            
            // Создаем карту ГРСИ -> номер документа (первый попавшийся)
            const grsiToDocumentMap = {};
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            if (lines.length > HEADER_SKIP_LINES + 1) {
                const dataLines = lines.slice(HEADER_SKIP_LINES + 1);
                dataLines.forEach((line) => {
                    const fields = parseCsvLine(line, usedDelimiter);
                    if (fields.length > COL_INDEX.GRSI && fields.length > COL_INDEX.Document) {
                        const grsi = fields[COL_INDEX.GRSI].trim();
                        const document = fields[COL_INDEX.Document].trim();
                        if (grsi && document && !grsiToDocumentMap[grsi]) {
                            const docNumber = document.split('/').pop();
                            grsiToDocumentMap[grsi] = docNumber;
                        }
                    }
                });
            }
            
            const missingGrsi = [];
            uniqueGrsiNumbers.forEach(grsi => {
                const config = mpiMonthsMap[grsi];
                if (!config || (config.manual === false && !config.value)) {
                    missingGrsi.push(grsi);
                }
            });

            if (missingGrsi.length > 0) {
                missingMpiContainer.classList.remove('hidden');
                logError(`Обнаружено ${missingGrsi.length} уникальных номеров ГРСИ без сопоставления МПИ.`);
                
                missingMpiForm.innerHTML = ''; 
                missingGrsi.forEach(grsi => {
                    const docNumber = grsiToDocumentMap[grsi] || '';
                    const div = document.createElement('div');
                    div.className = 'flex flex-col sm:flex-row items-center gap-2 bg-white dark:bg-slate-800 p-2 rounded shadow-sm border border-orange-200 dark:border-orange-800';
                    div.innerHTML = `
                        <div class="flex items-center justify-between w-full sm:w-2/5">
                            <span class="font-medium text-gray-800 dark:text-gray-200 text-sm truncate" title="${grsi}">ГРСИ №: ${grsi}</span>
                            ${docNumber ? `
                                <button type="button" class="ml-2 p-1 bg-blue-100 hover:bg-blue-200 text-blue-600 rounded text-xs flex items-center justify-center w-6 h-6" 
                                        title="Найти в ФГИС" onclick="window.open('https://fgis.gost.ru/fundmetrology/cm/results/1-${docNumber}', '_blank')">
                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                                    </svg>
                                </button>
                            ` : ''}
                        </div>
                        <input type="text" data-type="${grsi}" placeholder="МПИ (месяцы) или -" pattern="^[0-9]+$|^-$"
                               class="mpi-input flex-1 p-1 border border-gray-300 dark:border-slate-600 dark:bg-slate-700 dark:text-white rounded text-sm w-full" autocomplete="off">
                    `;
                    missingMpiForm.appendChild(div);
                });
                saveMissingMpiButton.onclick = handleMissingMpiSubmission;
                return true; 
            } else {
                missingMpiContainer.classList.add('hidden');
                logMessage('Все номера ГРСИ из файла успешно сопоставлены с данными МПИ.');
                return false;
            }
        }

        /**
         * Проверяет наличие записей с ручным вводом МПИ и отображает форму для их ввода
         */
        function checkAndDisplayManualMpi(csvContent, usedDelimiter) {
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            if (lines.length <= HEADER_SKIP_LINES + 1) return false;

            const dataLines = lines.slice(HEADER_SKIP_LINES + 1);
            
            // Собираем уникальные документы для записей с ручным вводом
            const manualDocuments = new Map(); // ключ: Document, значение: {grsi, document, type}
            
            dataLines.forEach((line) => {
                const fields = parseCsvLine(line, usedDelimiter);
                if (fields.length > COL_INDEX.GRSI && fields.length > COL_INDEX.Document && fields.length > COL_INDEX.Type) {
                    const grsi = fields[COL_INDEX.GRSI].trim();
                    const document = fields[COL_INDEX.Document].trim();
                    const type = fields[COL_INDEX.Type].trim();
                    
                    if (grsi && document && mpiMonthsMap[grsi] && mpiMonthsMap[grsi].manual === true) {
                        const docNumber = document.split('/').pop();
                        if (!manualDocuments.has(docNumber)) {
                            manualDocuments.set(docNumber, { 
                                grsi, 
                                document: docNumber,
                                type: type || 'Не указан'
                            });
                        }
                    }
                }
            });

            // Фильтруем документы, для которых еще не введены МПИ
            const documentsWithoutMpi = [];
            manualDocuments.forEach((record, docNumber) => {
                if (!manualMpiTempStorage[docNumber]) {
                    documentsWithoutMpi.push({ ...record, docNumber });
                }
            });

            if (documentsWithoutMpi.length > 0) {
                manualMpiContainer.classList.remove('hidden');
                logMessage(`Обнаружено ${documentsWithoutMpi.length} записей, требующих ручного ввода МПИ по номеру документа.`, 'INFO');
                
                manualMpiForm.innerHTML = '';
                documentsWithoutMpi.forEach(record => {
                    const div = document.createElement('div');
                    div.className = 'flex flex-col sm:flex-row items-center gap-2 bg-white dark:bg-slate-800 p-3 rounded shadow-sm border border-purple-200 dark:border-purple-800';
                    div.innerHTML = `
                        <div class="flex items-center justify-between w-full sm:w-2/5">
                            <div>
                                <div class="font-medium text-gray-800 dark:text-gray-200 text-sm">Документ: ${record.document}</div>
                                <div class="text-xs text-gray-500 dark:text-gray-400">ГРСИ: ${record.grsi}, Тип: ${record.type}</div>
                            </div>
                            <button type="button" class="ml-2 p-1 bg-blue-100 hover:bg-blue-200 text-blue-600 rounded text-xs flex items-center justify-center w-6 h-6" 
                                    title="Найти в ФГИС" onclick="window.open('https://fgis.gost.ru/fundmetrology/cm/results/1-${record.document}', '_blank')">
                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                                </svg>
                            </button>
                        </div>
                        <input type="text" data-document="${record.document}" data-grsi="${record.grsi}" placeholder="МПИ (месяцы) или -" pattern="^[0-9]+$|^-$"
                               class="manual-mpi-input flex-1 p-2 border border-gray-300 dark:border-slate-600 dark:bg-slate-700 dark:text-white rounded text-sm w-full" autocomplete="off">
                    `;
                    manualMpiForm.appendChild(div);
                });
                saveManualMpiButton.onclick = handleManualMpiSubmission;
                return true;
            } else {
                manualMpiContainer.classList.add('hidden');
                if (manualDocuments.size > 0) {
                    logMessage(`Все ${manualDocuments.size} записей с ручным вводом МПИ уже имеют введенные значения.`, 'INFO');
                }
                return false;
            }
        }

        function handleMissingSnilsSubmission(e) {
            e.preventDefault();
            const inputs = missingSnilsForm.querySelectorAll('.snils-input');
            let newMappingsCount = 0;
            let errorFound = false;

            inputs.forEach(input => {
                const author = input.dataset.author;
                const snils = input.value.trim();

                input.classList.remove('border-red-500', 'bg-red-50', 'border-emerald-500', 'bg-emerald-50', 'dark:border-red-500', 'dark:bg-red-900/20', 'dark:border-emerald-500', 'dark:bg-emerald-900/20');
                
                if (snils.length > 0) {
                    if (snils.match(/^\d{11}$/)) {
                        if (!(author in authorSnilsMap) || authorSnilsMap[author] !== snils) {
                            authorSnilsMap[author] = snils;
                            newMappingsCount++;
                        }
                        input.classList.add('border-emerald-500', 'bg-emerald-50', 'dark:border-emerald-500', 'dark:bg-emerald-900/20');
                        input.disabled = true; 
                    } else {
                        logError(`Некорректный СНИЛС для "${author}". Ожидается 11 цифр.`);
                        input.classList.add('border-red-500', 'bg-red-50', 'dark:border-red-500', 'dark:bg-red-900/20');
                        errorFound = true;
                    }
                }
            });

            if (errorFound) {
                logMessage('Не все СНИЛС сохранены из-за ошибок валидации. Исправьте выделенные поля.', 'ERROR');
                return;
            }

            if (newMappingsCount > 0) {
                saveAndRenderMappings();
                logMessage(`Успешно добавлено/обновлено ${newMappingsCount} сопоставлений СНИЛС.`);
            } else {
                logMessage('Нет новых данных СНИЛС для сохранения.');
            }
            
            if (errorFound === false) {
                 missingAuthorsContainer.classList.add('hidden');
                 if (lastCsvContent && lastDelimiter) {
                     logMessage('Все недостающие СНИЛС сохранены. Автоматический перезапуск конвертации...');
                     runConversionProcess(lastCsvContent, lastDelimiter);
                 } else {
                     updateStatus('Сопоставления СНИЛС обновлены. Загрузите CSV-файл для конвертации.');
                 }
            }
        }
        
        function handleMissingMpiSubmission(e) {
            e.preventDefault();
            const inputs = missingMpiForm.querySelectorAll('.mpi-input');
            let newMappingsCount = 0;
            let errorFound = false;

            inputs.forEach(input => {
                const grsiNumber = input.dataset.type; 
                const rawValue = input.value.trim();
                const isNoExpiry = rawValue === MPI_NO_EXPIRY_MARK;
                const mpi = parseInt(rawValue, 10);

                input.classList.remove('border-red-500', 'bg-red-50', 'border-emerald-500', 'bg-emerald-50', 'dark:border-red-500', 'dark:bg-red-900/20', 'dark:border-emerald-500', 'dark:bg-emerald-900/20');
                
                if (isNoExpiry || (!isNaN(mpi) && mpi > 0)) {
                    const valueToStore = isNoExpiry ? MPI_NO_EXPIRY_MARK : mpi;
                    if (!mpiMonthsMap[grsiNumber] || mpiMonthsMap[grsiNumber].value !== valueToStore) {
                        mpiMonthsMap[grsiNumber] = {
                            value: valueToStore,
                            manual: false
                        };
                        newMappingsCount++;
                    }
                    input.classList.add('border-emerald-500', 'bg-emerald-50', 'dark:border-emerald-500', 'dark:bg-emerald-900/20');
                    input.disabled = true; 
                } else if (rawValue !== '') {
                    logError(`Некорректный МПИ для ГРСИ №${grsiNumber}. Ожидается целое число месяцев > 0 или "${MPI_NO_EXPIRY_MARK}".`);
                    input.classList.add('border-red-500', 'bg-red-50', 'dark:border-red-500', 'dark:bg-red-900/20');
                    errorFound = true;
                }
            });

            if (errorFound) {
                logMessage('Не все МПИ сохранены из-за ошибок валидации. Исправьте выделенные поля.', 'ERROR');
                return;
            }

            if (newMappingsCount > 0) {
                saveAndRenderMpiMappings();
                logMessage(`Успешно добавлено/обновлено ${newMappingsCount} сопоставлений МПИ.`);
            } else {
                logMessage('Нет новых данных МПИ для сохранения.');
            }
            
            if (errorFound === false) {
                 missingMpiContainer.classList.add('hidden');
                 if (lastCsvContent && lastDelimiter) {
                     logMessage('Все недостающие МПИ сохранены. Автоматический перезапуск конвертации...');
                     runConversionProcess(lastCsvContent, lastDelimiter);
                 } else {
                     updateStatus('Сопоставления МПИ обновлены. Загрузите CSV-файл для конвертации.');
                 }
            }
        }

        /**
         * Обработчик сохранения ручных МПИ (временное хранилище, не в localStorage)
         */
        function handleManualMpiSubmission(e) {
            e.preventDefault();
            e.stopPropagation(); // Добавляем остановку распространения события
            
            const inputs = manualMpiForm.querySelectorAll('.manual-mpi-input');
            let errorFound = false;
            let savedCount = 0;

            // Временное хранилище для сохраненных значений
            const tempSavedValues = {};

            inputs.forEach(input => {
                const documentNum = input.dataset.document;
                const grsi = input.dataset.grsi;
                const rawValue = input.value.trim();
                const isNoExpiry = rawValue === MPI_NO_EXPIRY_MARK;
                const mpi = parseInt(rawValue, 10);

                input.classList.remove('border-red-500', 'bg-red-50', 'border-emerald-500', 'bg-emerald-50', 'dark:border-red-500', 'dark:bg-red-900/20', 'dark:border-emerald-500', 'dark:bg-emerald-900/20');
                
                if (rawValue === '') {
                    logError(`Для документа №${documentNum} (ГРСИ ${grsi}) необходимо ввести МПИ.`);
                    input.classList.add('border-red-500', 'bg-red-50', 'dark:border-red-500', 'dark:bg-red-900/20');
                    errorFound = true;
                } else if (isNoExpiry || (!isNaN(mpi) && mpi > 0)) {
                    const valueToStore = isNoExpiry ? MPI_NO_EXPIRY_MARK : mpi;
                    tempSavedValues[documentNum] = valueToStore;
                    savedCount++;
                    input.classList.add('border-emerald-500', 'bg-emerald-50', 'dark:border-emerald-500', 'dark:bg-emerald-900/20');
                    input.disabled = true;
                } else {
                    logError(`Некорректный МПИ для документа №${documentNum} (ГРСИ ${grsi}). Ожидается целое число месяцев > 0 или "${MPI_NO_EXPIRY_MARK}".`);
                    input.classList.add('border-red-500', 'bg-red-50', 'dark:border-red-500', 'dark:bg-red-900/20');
                    errorFound = true;
                }
            });

            if (errorFound) {
                logMessage('Не все ручные МПИ сохранены из-за ошибок валидации. Исправьте выделенные поля.', 'ERROR');
                return;
            }

            if (savedCount > 0) {
                // Сохраняем значения во временное хранилище
                Object.assign(manualMpiTempStorage, tempSavedValues);
                logMessage(`Успешно сохранено ${savedCount} ручных МПИ (временное хранилище).`);
            } else {
                logMessage('Нет новых данных ручных МПИ для сохранения.');
                return;
            }

            manualMpiContainer.classList.add('hidden');
            
            // Не очищаем временное хранилище при перезапуске
            // Сохраняем текущие значения в переменной перед перезапуском
            const savedManualMpi = {...manualMpiTempStorage};
            
            // Создаем копию данных для безопасного перезапуска
            if (lastCsvContent && lastDelimiter) {
                logMessage('Все ручные МПИ сохранены. Автоматический перезапуск конвертации...');
                
                // Восстанавливаем сохраненные значения перед перезапуском
                setTimeout(() => {
                    // Восстанавливаем сохраненные значения
                    manualMpiTempStorage = savedManualMpi;
                    runConversionProcess(lastCsvContent, lastDelimiter);
                }, 300);
            } else {
                updateStatus('Ручные МПИ обновлены. Загрузите CSV-файл для конвертации.');
            }
        }

        // --- ОСНОВНАЯ ЛОГИКА КОНВЕРТАЦИИ ---
        
        /**
         * Runs the full conversion process with pre-loaded content.
         * @param {string} csvContent - Full content of the CSV file.
         * @param {string} usedDelimiter - Delimiter used in the CSV.
         */
        async function runConversionProcess(csvContent, usedDelimiter) {
            startProcessing(false); // false = не новый файл, не очищаем ручные МПИ
            const startTime = performance.now();
            
            try {
                const uniqueAuthors = getUniqueValuesFromCsv(csvContent, usedDelimiter, COL_INDEX.Author);

                const missingSnils = checkAndDisplayMissingAuthors(uniqueAuthors);
                const missingMpi = checkAndDisplayMissingMpi(csvContent, usedDelimiter);
                const manualMpi = checkAndDisplayManualMpi(csvContent, usedDelimiter);
                
                if (missingSnils || missingMpi || manualMpi) {
                    throw new Error("Требуется ввод недостающих данных (СНИЛС, МПИ или ручные МПИ). Исправьте выделенные блоки.");
                }
                
                // --- 3. Парсинг и фильтрация всех валидных записей ---
                allProcessedRecords = parseAndValidateRecords(csvContent, usedDelimiter);
                
                if (allProcessedRecords.length === 0) {
                    throw new Error("Ошибка: Не найдено валидных записей для конвертации. Проверьте лог отладки.");
                }
                
                // --- 4. Завершение ---
                const elapsedTime = performance.now() - startTime;
                const delay = Math.max(0, MIN_PROCESSING_TIME - elapsedTime);

                setTimeout(() => {
                    stopProcessing();
                    updateSuccess(allProcessedRecords.length);
                    
                    // Назначаем обработчик скачивания
                    downloadButton.onclick = handleDownload;
                }, delay);

            } catch(e) {
                 const errorMessage = e.message.startsWith("Требуется ввод") ? e.message : `Критическая ошибка обработки данных: ${e.message}`;
                 logError(`КРИТИЧЕСКАЯ ОШИБКА В КОНВЕРТАЦИИ: ${errorMessage}`);
                 updateStatus(errorMessage, true);
                 stopProcessing();
            }
        }
        
        /**
         * Парсит CSV, валидирует, применяет сопоставления и возвращает массив готовых объектов для XML.
         * @returns {Array<Object>} Массив валидных записей с готовыми полями для XML.
         */
        function parseAndValidateRecords(csvContent, usedDelimiter) {
            logMessage('Начало парсинга и валидации записей...');
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            const csvTextWithHeader = lines.slice(HEADER_SKIP_LINES);
            const dataLines = csvTextWithHeader.slice(1); 
            
            const dataRecords = dataLines.map((line) => parseCsvLine(line, usedDelimiter)).filter(fields => fields.length > 0); 
            
            logMessage(`Найдено ${dataRecords.length} потенциальных строк для конвертации.`);

            const validRecords = [];
            
            for (let i = 0; i < dataRecords.length; i++) {
                const fields = dataRecords[i];
                const lineNumber = i + HEADER_SKIP_LINES + 2; 

                if (fields.length < COL_INDEX.Document + 1 || fields.length < COL_INDEX.GRSI + 1) {
                     logError(`Строка ${lineNumber}: Пропущена: недостаточно столбцов.`);
                     continue;
                }

                try {
                    const authorFull = fields[COL_INDEX.Author].trim();
                    const documentNum = fields[COL_INDEX.Document];

                    if (!documentNum || documentNum.trim() === '') {
                        logError(`Строка ${lineNumber} (${documentNum}): Пропущена, отсутствует номер документа (колонка ${COL_INDEX.Document}).`);
                        continue;
                    }
                    
                    const snils = authorSnilsMap[authorFull];
                    const grsiNumber = fields[COL_INDEX.GRSI].trim();         
                    const mpiConfig = mpiMonthsMap[grsiNumber];
                    
                    // Эти проверки должны были быть сделаны до вызова, но дублируем для безопасности
                    if (!snils) { 
                        logError(`Строка ${lineNumber} (${documentNum}): Отсутствует сопоставление СНИЛС для автора: "${authorFull}".`); 
                        continue; 
                    }
                    
                    if (!mpiConfig) { 
                        logError(`Строка ${lineNumber} (${documentNum}): Отсутствует сопоставление МПИ для ГРСИ №: "${grsiNumber}".`); 
                        continue; 
                    }

                    let mpiMonths;
                    if (mpiConfig.manual === true) {
                        // Для ручных записей ищем МПИ по номеру документа во временном хранилище
                        const docNumber = documentNum.split('/').pop();
                        mpiMonths = manualMpiTempStorage[docNumber];
                        if (!mpiMonths) {
                            logError(`Строка ${lineNumber} (${documentNum}): Для ГРСИ №${grsiNumber} (отмечен как 'Вручную') не введен МПИ по документу ${docNumber}.`);
                            continue;
                        }
                    } else {
                        // Для обычных записей берем значение из конфигурации
                        mpiMonths = mpiConfig.value;
                        if (!mpiMonths) {
                            logError(`Строка ${lineNumber} (${documentNum}): Отсутствует значение МПИ для ГРСИ №: "${grsiNumber}".`);
                            continue;
                        }
                    }

                    // --- Валидация и Форматирование ---
                    const dateVerification = fields[COL_INDEX.Date];
                    const dateVerificationClean = dateVerification.split(' ')[0];
                    const formattedDateVerification = formatDateToISO(dateVerificationClean);
                    
                    if (formattedDateVerification === "") {
                         logError(`Строка ${lineNumber} (${documentNum}): Не удалось преобразовать дату "${dateVerificationClean}".`);
                         continue;
                    }
                    
                    const dateEndVerification = calculateDateEndVerification(dateVerificationClean, mpiMonths);
                    const resultVerification = mapSuitability(fields[COL_INDEX.Suitability]);
                    
                    // Разделение ФИО
                    const authorParts = authorFull.split(/\s+/).filter(p => p.length > 0);
                    const lastName = authorParts[0] || "Неизвестный";
                    const firstName = authorParts.slice(1).join(' ') || "Автор";
                    
                    // Сохраняем готовую запись
                    validRecords.push({
                        lineNumber,
                        documentNum,
                        typeInstrument: fields[COL_INDEX.Type].trim(),
                        formattedDateVerification,
                        dateEndVerification,
                        resultVerification,
                        lastName,
                        firstName,
                        snils
                    });

                } catch (e) {
                    logError(`Строка ${lineNumber}: Критическая ошибка обработки: ${e.message}.`);
                }
            }
            
            logMessage(`Парсинг завершен. Всего валидных записей: ${validRecords.length}.`);
            return validRecords;
        }

        /**
         * Генерирует XML-контент для заданного массива записей.
         * @param {Array<Object>} records - Массив записей, возвращенный parseAndValidateRecords.
         * @returns {string} Готовая XML-строка.
         */
        function generateXmlContent(records) {
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<Message xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="schema.xsd">\n';
            xml += '    <VerificationMeasuringInstrumentData>\n';
            
            const escape = (str) => str ? str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;') : '';

            records.forEach(record => {
                xml += '        <VerificationMeasuringInstrument>\n';
                xml += `            <NumberVerification>${escape(record.documentNum)}</NumberVerification>\n`;
                xml += `            <DateVerification>${escape(record.formattedDateVerification)}</DateVerification>\n`;
                
                if (record.resultVerification === '1' && record.dateEndVerification) {
                    xml += `            <DateEndVerification>${escape(record.dateEndVerification)}</DateEndVerification>\n`;
                } else if (record.resultVerification === '1' && !record.dateEndVerification) {
                    logMessage(`Строка ${record.lineNumber} (${record.documentNum}): Не удалось рассчитать DateEndVerification. Поле пропущено.`, 'WARN');
                }
                
                xml += `            <TypeMeasuringInstrument>${escape(record.typeInstrument)}</TypeMeasuringInstrument>\n`;
                xml += '            <ApprovedEmployees>\n';
                xml += '                <Name>\n';
                xml += `                    <Last>${escape(record.lastName)}</Last>\n`;
                xml += `                    <First>${escape(record.firstName)}</First>\n`;
                xml += '                </Name>\n';
                xml += `                <SNILS>${escape(record.snils)}</SNILS>\n`;
                xml += '            </ApprovedEmployees>\n';
                xml += `            <ResultVerification>${record.resultVerification}</ResultVerification>\n`;
                xml += '        </VerificationMeasuringInstrument>\n';
            });

            xml += '    </VerificationMeasuringInstrumentData>\n';
            xml += '    <SaveMethod>2</SaveMethod>\n';
            xml += '</Message>';

            return xml;
        }

        /**
         * Загрузка одного файла.
         */
        function downloadXML(xmlContent, filename) {
            const blob = new Blob([xmlContent], { type: 'text/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename; 
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logMessage(`XML-файл "${filename}" создан и загружен.`);
        }
        
        /**
         * НОВЫЙ ХЕНДЛЕР СКАЧИВАНИЯ, УЧИТЫВАЮЩИЙ РАЗДЕЛЕНИЕ.
         */
        function handleDownload() {
            if (!allProcessedRecords || allProcessedRecords.length === 0) {
                logError('Нет данных для скачивания.');
                return;
            }
            
            const shouldSplit = splitOutputCheckbox.checked;
            const filenameBase = lastFileNameBase;
            const records = allProcessedRecords;
            const totalRecords = records.length;
            
            downloadButton.disabled = true; // Отключаем кнопку на время загрузки
            downloadButton.textContent = shouldSplit ? 'Начало загрузки...' : 'Скачивание...';

            if (shouldSplit) {
                // Логика разделения и последовательной загрузки
                const numChunks = Math.ceil(totalRecords / MAX_RECORDS_PER_FILE);
                logMessage(`Разделение на ${numChunks} файлов по ${MAX_RECORDS_PER_FILE} записей.`);
                
                let currentChunk = 0;
                
                function downloadNextChunk() {
                    if (currentChunk < numChunks) {
                        const start = currentChunk * MAX_RECORDS_PER_FILE;
                        const end = Math.min(start + MAX_RECORDS_PER_FILE, totalRecords);
                        const chunkRecords = records.slice(start, end);
                        
                        const chunkXml = generateXmlContent(chunkRecords);
                        const filename = `${filenameBase}_part_${currentChunk + 1}-of-${numChunks}.xml`;
                        
                        // Используем setTimeout(0) для асинхронного скачивания, чтобы избежать блокировки
                        setTimeout(() => {
                            downloadXML(chunkXml, filename);
                            downloadButton.textContent = `Загрузка файла ${currentChunk + 1} из ${numChunks}...`;
                            currentChunk++;
                            downloadNextChunk(); // Рекурсивный вызов для следующего файла
                        }, 500); // Небольшая задержка, чтобы помочь браузеру обработать множественные запросы
                    } else {
                        logMessage('Все части XML-файлов успешно загружены.');
                        downloadButton.disabled = false;
                        downloadButton.textContent = 'Скачать XML-файл';
                    }
                }
                
                downloadNextChunk();

            } else {
                // Логика загрузки одного файла
                const finalXmlContent = generateXmlContent(records);
                const filename = `${filenameBase}.xml`;
                
                downloadXML(finalXmlContent, filename);
                
                downloadButton.disabled = false;
                downloadButton.textContent = 'Скачать XML-файл';
            }
        }
        
        function readFileWithEncoding(file, encoding) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file, encoding);
            });
        }

        // --- ОБРАБОТЧИКИ СОБЫТИЙ ---

        async function handleFiles(files) {
            if (files.length === 0) return;

            const file = files[0];
            if (!file.name.toLowerCase().endsWith('.csv')) {
                updateStatus("Ошибка: Пожалуйста, выберите файл CSV.", true);
                logError(`Выбран не CSV файл: ${file.name}`);
                return;
            }

            fileNameDisplay.textContent = `Выбран файл: ${file.name}`;
            startProcessing(true); // true = новый файл, очищаем ручные МПИ

            let csvContent = null;
            let usedDelimiter = null;

            try {
                logMessage('Чтение файла с автоопределением кодировки...');
                let content = await readFileWithEncoding(file, 'UTF-8');
                
                if (hasEncodingIssues(content)) {
                    content = await readFileWithEncoding(file, 'windows-1251');
                    logMessage(`Файл успешно прочитан с использованием кодировки Windows-1251.`);
                } else {
                    logMessage('Файл успешно прочитан с кодировкой UTF-8.');
                }
                csvContent = content;
                usedDelimiter = detectDelimiter(csvContent.split('\n')[HEADER_SKIP_LINES]);

                // --- Сохраняем для автоперезапуска и для проверки отсутствующих данных ---
                lastCsvContent = csvContent;
                lastDelimiter = usedDelimiter;
                lastFileNameBase = generateFileNameBase(); // Генерируем базое имя файла

                
                // --- 2. Запуск процесса (который теперь включает проверку отсутствующих данных) ---
                await runConversionProcess(lastCsvContent, lastDelimiter);

            } catch(e) {
                 const errorMessage = `Критическая ошибка чтения файла: ${e.message}`;
                 logError(errorMessage);
                 updateStatus(errorMessage, true);
                 stopProcessing();
            }
        }

        // Drop Area Events
        dropArea.addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
            e.target.value = null; 
        });

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('active'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('active'), false);
        });

        dropArea.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }, false);

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // --- Прикрепление обработчиков форм и JSON I/O ---
        snilsMappingForm.addEventListener('submit', handleMappingForm);
        mpiMappingForm.addEventListener('submit', handleMpiMappingForm);

        // JSON I/O Handlers
        exportSnilsButton.addEventListener('click', exportSnilsMap);
        importSnilsButton.addEventListener('click', () => importSnilsFile.click());
        importSnilsFile.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importSnilsMapHandler(e.target.files[0]);
            }
            e.target.value = null; 
        });

        exportMpiButton.addEventListener('click', exportMpiMap);
        importMpiButton.addEventListener('click', () => importMpiFile.click());
        importMpiFile.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importMpiMapHandler(e.target.files[0]);
            }
            e.target.value = null; 
        });
        
        // --- НОВЫЙ ХЕНДЛЕР: Перезапуск конвертации при смене опции разделения, если файл уже загружен ---
        splitOutputCheckbox.addEventListener('change', () => {
             if (allProcessedRecords.length > 0) {
                 updateSuccess(allProcessedRecords.length);
             }
        });

        // Обработчик для чекбокса "Вручную" - управление полем ввода МПИ
        manualCheckbox.addEventListener('change', function() {
            if (this.checked) {
                mpiMonthsConfigInput.disabled = true;
                mpiMonthsConfigInput.value = '';
                mpiMonthsConfigInput.removeAttribute('required');
                mpiMonthsConfigInput.removeAttribute('pattern');
            } else {
                mpiMonthsConfigInput.disabled = false;
                mpiMonthsConfigInput.setAttribute('required', '');
                mpiMonthsConfigInput.setAttribute('pattern', '^[0-9]+$|^-$');
            }
        });


        // Инициализация
        loadMappings(); 
        updateStatus("Готов к работе!");
    </script>
</body>
</html>
