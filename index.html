<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Конвертер данных для ФГИС ФСА</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; 
            min-height: 100vh;
            background-image: linear-gradient(0deg, transparent 14px, rgba(160, 174, 192, 0.15) 15px),
                              linear-gradient(90deg, transparent 14px, rgba(160, 174, 192, 0.15) 15px);
            background-size: 15px 15px; 
            background-attachment: fixed;
        }
        
        /* Главная карточка */
        .main-card {
            background-color: #ffffff;
        }

        .drag-area {
            border: 3px dashed #94a3b8; /* slate-400 */
            transition: all 0.3s ease;
        }
        .drag-area.active {
            border-color: #0ea5e9; /* sky-500 */
            background-color: #f0f9ff; /* sky-50 */
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.2); /* ring effect for focus */
        }
        
        details[open] summary svg {
            transform: rotate(180deg);
        }
        
        /* Анимация полос прогресса */
        @keyframes progress-stripes {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .animate-progress-stripes {
            width: 200%; 
            animation: progress-stripes 2s linear infinite;
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.15) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.15) 50%,
                rgba(255, 255, 255, 0.15) 75%,
                transparent 75%,
                transparent
            );
            background-size: 1rem 1rem;
            will-change: transform;
        }
        
        .snils-input:focus, .mpi-input:focus {
             outline: none;
             border-color: #f97316; /* orange-500 */
             box-shadow: 0 0 0 1px #f97316;
        }
        
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'accent-sky': '#0ea5e9', // sky-500 for primary
                        'accent-emerald': '#10b981', // emerald-500 for success
                    }
                }
            }
        }
    </script>
</head>
<body class="p-4 md:p-12">

    <!-- Главная карточка - чистая, белая, с акцентной рамкой -->
    <div class="max-w-4xl mx-auto main-card p-6 md:p-10 rounded-xl shadow-xl border-t-4 border-accent-sky">
        <header class="mb-8 border-b border-gray-200 pb-4">
            <h1 class="text-3xl font-bold text-gray-800 mb-1">
                <span class="text-accent-sky">|</span> Конвертер данных <span class="text-accent-sky">ФГИС</span>
            </h1>
            <p class="text-gray-500 text-base">
                Преобразование выгрузки ФГИС "АРШИН" в формат для загрузки в ФГИС ФСА.
            </p>
        </header>

        <!-- Instruction Guide Block -->
        <details class="mb-8 p-4 bg-sky-50 border border-sky-200 rounded-lg">
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-sky-800 focus:outline-none">
                <span>
                    <svg class="w-5 h-5 inline-block mr-2 text-sky-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    Инструкция по подготовке файла (ВАЖНО)
                </span>
                <svg class="w-4 h-4 text-sky-600 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            
            <div class="mt-3 text-sm text-gray-700 space-y-3">
                <p class="font-bold text-sky-900">1. Проверка структуры файла:</p>
                <p>Ваш файл должен быть экспортирован из реестра таким образом, чтобы заголовок таблицы начинался с <span class="font-mono bg-sky-100 p-1 rounded">3-й строки</span> (первые две строки – это метаданные, которые конвертер автоматически пропустит).</p>
                
                <p class="font-bold text-sky-900">2. Обязательные колонки (Индекс = номер колонки, начиная с 0):</p>
                <ul class="list-disc list-inside ml-4 space-y-1 bg-white p-3 rounded border">
                    <li><span class="font-mono">Author</span> (Индекс **1**): ФИО автора записи. **Требуется сопоставление СНИЛС.**</li>
                    <li><span class="font-mono">Type</span> (Индекс **3**): Наименование типа СИ. (Используется для тега TypeMeasuringInstrument в XML)</li>
                    <li><span class="font-mono">GRSI</span> (Индекс **4**): Номер записи в ГРСИ. **Требуется сопоставление МПИ.**</li>
                    <li><span class="font-mono">Date</span> (Индекс **5**): Дата поверки.</li>
                    <li><span class="font-mono">Suitability</span> (Индекс **9**): Пригодность ("Да" или "Нет").</li>
                    <li><span class="font-mono">Document</span> (Индекс **10**): Номер документа (протокола) поверки.</li>
                </ul>
                
                <p class="font-bold text-sky-900">3. Сохранение в формат CSV:</p>
                <p>В Excel выберите "Сохранить как" и выберите тип файла <span class="font-medium">CSV (разделители-запятые)</span> или <span class="font-medium">CSV (разделители-точки с запятой)</span>. Конвертер автоматически определит разделитель.</p>
                
                <p class="text-xs italic mt-4 text-sky-700">
                    <span class="font-semibold">Расчет МПИ:</span> Дата окончания поверки рассчитывается как (Дата Поверки + МПИ в месяцах - 1 день).
                </p>
            </div>
        </details>
        
        <!-- Input and Status Section -->
        <div class="space-y-6">
            
            <!-- БЛОК 1: Загрузка файла (Drag-n-Drop) -->
            <div>
                <h2 class="text-xl font-semibold text-gray-700 mb-3 border-b pb-1">
                    Загрузка исходного CSV
                </h2>
                <div id="drop-area" class="drag-area p-8 rounded-lg text-center cursor-pointer transition-all hover:ring-2 hover:ring-offset-2 hover:ring-sky-300">
                    <input type="file" id="fileInput" accept=".csv" class="hidden">
                    <svg class="mx-auto h-12 w-12 text-accent-sky" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 014 4v2a4 4 0 01-4 4H7z" />
                    </svg>
                    <p class="mt-2 text-sm text-gray-600">
                        Перетащите CSV-файл сюда или <span class="text-accent-sky font-semibold">нажмите для выбора</span>
                    </p>
                    <p id="fileNameDisplay" class="text-xs text-gray-400 mt-1"></p>
                </div>
            </div>
            
            <!-- БЛОК ПРЕДУПРЕЖДЕНИЯ О НЕДОСТАЮЩИХ АВТОРАХ (СНИЛС) -->
            <div id="missingAuthorsContainer" class="hidden p-4 bg-red-100 border-l-4 border-red-500 rounded-lg shadow-md">
                <div class="flex items-start">
                    <svg class="h-6 w-6 text-red-600 mt-1 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.3 16c-.77 1.333.192 3 1.732 3z" />
                    </svg>
                    <div class="ml-3 w-full">
                        <h3 class="text-lg font-semibold text-red-800">
                            Обнаружены недостающие СНИЛС!
                        </h3>
                        <p class="mt-1 text-sm text-red-700">
                            Введите СНИЛС для следующих авторов, чтобы не пропускать их записи.
                        </p>
                        <!-- ДИНАМИЧЕСКАЯ ФОРМА ДЛЯ БЫСТРОГО ВВОДА СНИЛС -->
                        <form id="missingSnilsForm" class="mt-2 text-sm bg-red-50 p-3 rounded max-h-56 overflow-y-auto space-y-2">
                            <!-- Список авторов и полей ввода будет сгенерирован здесь -->
                        </form>
                        <button id="saveMissingSnilsButton" class="w-full mt-3 bg-red-600 text-white font-bold py-2 rounded-lg hover:bg-red-700 transition-colors duration-200">
                            Сохранить все недостающие СНИЛС
                        </button>
                    </div>
                </div>
            </div>

            <!-- БЛОК: ПРЕДУПРЕЖДЕНИЕ О НЕДОСТАЮЩИХ МПИ (Ключ - ГРСИ) -->
            <div id="missingMpiContainer" class="hidden p-4 bg-orange-100 border-l-4 border-orange-500 rounded-lg shadow-md">
                <div class="flex items-start">
                    <svg class="h-6 w-6 text-orange-600 mt-1 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h.01M17 11h.01M9 15h.01M15 15h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" /></svg>
                    <div class="ml-3 w-full">
                        <h3 class="text-lg font-semibold text-orange-800">
                            Обнаружены недостающие МПИ!
                        </h3>
                        <p class="mt-1 text-sm text-orange-700">
                            Введите Межповерочный Интервал (в месяцах) для следующих Номеров записи ГРСИ.
                        </p>
                        <!-- ДИНАМИЧЕСКАЯ ФОРМА ДЛЯ БЫСТРОГО ВВОДА МПИ -->
                        <form id="missingMpiForm" class="mt-2 text-sm bg-orange-50 p-3 rounded max-h-56 overflow-y-auto space-y-2">
                            <!-- Список типов СИ и полей ввода будет сгенерирован здесь -->
                        </form>
                        <button id="saveMissingMpiButton" class="w-full mt-3 bg-orange-600 text-white font-bold py-2 rounded-lg hover:bg-orange-700 transition-colors duration-200">
                            Сохранить все недостающие МПИ
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- НОВЫЙ БЛОК: ОПЦИЯ РАЗДЕЛЕНИЯ ФАЙЛОВ -->
            <div id="splitOutputContainer" class="p-3 bg-gray-100 rounded-lg border border-gray-200">
                <label for="splitOutputCheckbox" class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="splitOutputCheckbox" class="h-5 w-5 text-accent-sky border-gray-300 rounded focus:ring-accent-sky">
                    <span class="text-gray-700 font-medium select-none">
                        Разделить выходные файлы (максимально 1000 записей на файл).
                    </span>
                </label>
            </div>


            <!-- БЛОК 2: Статус и Скачивание -->
            <div class="p-4 bg-gray-50 rounded-lg shadow-inner border border-gray-200">
                <h2 class="text-xl font-semibold text-gray-700 mb-3 border-b pb-1">
                    Статус и результат
                </h2>
                
                <div id="statusMessage" class="text-gray-600 text-lg font-semibold mb-4">
                    Ожидание загрузки файла...
                </div>
                
                <!-- Processing Animation -->
                <div id="processingIndicator" class="mt-4 hidden">
                    <div class="h-2.5 bg-sky-200 rounded-full overflow-hidden">
                        <div class="h-full bg-accent-sky rounded-full animate-progress-stripes"></div>
                    </div>
                    <p class="text-xs text-accent-sky mt-1 font-medium animate-pulse">Обработка данных...</p>
                </div>

                <!-- Кнопка с accent-emerald -->
                <button id="downloadButton"
                        class="w-full mt-4 bg-emerald-500 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:bg-emerald-600 transition-colors duration-200 opacity-50 cursor-not-allowed disabled:shadow-none"
                        disabled>
                    Скачать XML-файл
                </button>
                <p id="recordCount" class="text-sm text-gray-500 mt-2 text-center hidden"></p>
            </div>
        </div>
        
        <!-- БЛОК 3: Управление сопоставлением Авторов и СНИЛС -->
        <details class="mt-8 p-4 bg-yellow-50 border border-yellow-300 rounded-lg" open>
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-yellow-800 focus:outline-none">
                <span>
                    <svg class="w-5 h-5 inline-block mr-2 text-yellow-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" /></svg>
                    Управление сотрудниками и СНИЛС.
                </span>
                <svg class="w-4 h-4 text-yellow-600 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            
            <div class="mt-4 space-y-4">
                <form id="snilsMappingForm" class="flex flex-col sm:flex-row gap-2">
                    <input type="text" id="authorNameInput" placeholder="ФИО автора (как в CSV)" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-yellow-500 focus:border-yellow-500 text-sm" autocomplete="off">
                    <input type="text" id="snilsInput" placeholder="СНИЛС (11 цифр)" pattern="^\d{11}$" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-yellow-500 focus:border-yellow-500 text-sm" autocomplete="off">
                    <button type="submit" class="bg-yellow-600 text-white p-2 rounded-lg font-medium hover:bg-yellow-700 transition duration-150 flex-shrink-0">
                        Добавить/Обновить
                    </button>
                </form>

                <!-- Добавлены кнопки Импорта/Экспорта СНИЛС -->
                <div class="flex gap-2">
                    <button id="exportSnilsButton" type="button" class="w-1/2 bg-gray-300 text-gray-800 p-2 rounded-lg font-medium hover:bg-gray-400 transition duration-150">
                        Экспорт JSON
                    </button>
                    <input type="file" id="importSnilsFile" accept=".json" class="hidden">
                    <button id="importSnilsButton" type="button" class="w-1/2 bg-gray-300 text-gray-800 p-2 rounded-lg font-medium hover:bg-gray-400 transition duration-150">
                        Импорт JSON
                    </button>
                </div>
                
                <div id="mappingListContainer" class="max-h-60 overflow-y-auto border border-gray-300 rounded-lg shadow-inner">
                    <!-- Mappings will be rendered here -->
                    <p class="p-4 text-gray-500 text-sm italic" id="emptyMappingMessage">
                        Нет сохраненных сопоставлений. Используйте форму выше или импортируйте JSON.
                    </p>
                </div>
            </div>
        </details>
        
        <!-- БЛОК 4: Управление сопоставлением ГРСИ и МПИ (Ключ - ГРСИ) -->
        <details class="mt-4 p-4 bg-green-50 border border-green-300 rounded-lg" open>
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-green-800 focus:outline-none">
                <span>
                    <svg class="w-5 h-5 inline-block mr-2 text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    Управление ГРСИ и МПИ.
                </span>
                <svg class="w-4 h-4 text-green-600 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            
            <div class="mt-4 space-y-4">
                <form id="mpiMappingForm" class="flex flex-col sm:flex-row gap-2">
                    <input type="text" id="instrumentTypeInput" placeholder="Номер записи ГРСИ (как в CSV, колонка 4)" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-green-500 focus:border-green-500 text-sm" autocomplete="off">
                    <input type="number" id="mpiMonthsConfigInput" placeholder="МПИ (месяцы, напр. 12, 24)" min="1" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-green-500 focus:border-green-500 text-sm" autocomplete="off">
                    <button type="submit" class="bg-green-600 text-white p-2 rounded-lg font-medium hover:bg-green-700 transition duration-150 flex-shrink-0">
                        Добавить/Обновить
                    </button>
                </form>
                
                <!-- Добавлены кнопки Импорта/Экспорта МПИ -->
                <div class="flex gap-2">
                    <button id="exportMpiButton" type="button" class="w-1/2 bg-gray-300 text-gray-800 p-2 rounded-lg font-medium hover:bg-gray-400 transition duration-150">
                        Экспорт JSON
                    </button>
                    <input type="file" id="importMpiFile" accept=".json" class="hidden">
                    <button id="importMpiButton" type="button" class="w-1/2 bg-gray-300 text-gray-800 p-2 rounded-lg font-medium hover:bg-gray-400 transition duration-150">
                        Импорт JSON
                    </button>
                </div>

                <div id="mpiMappingListContainer" class="max-h-60 overflow-y-auto border border-gray-300 rounded-lg shadow-inner">
                    <!-- Mappings will be rendered here -->
                    <p class="p-4 text-gray-500 text-sm italic" id="emptyMpiMessage">
                        Нет сохраненных интервалов МПИ. Используйте форму выше или импортируйте JSON.
                    </p>
                </div>
                <!-- Аккуратная навигационная ссылка -->
                <div class="mb-4 -mt-2"> 
                    <a href="/mpi.html" class="text-sm text-gray-500 hover:text-blue-600 transition duration-150 flex items-center font-medium">
                    <!-- Иконка стрелки влево для навигации -->
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                    К конвертеру ГРСИ и МПИ
                </a>
                </div>
            </div>
        </details>

        <!-- Debug Log Spoiler (Контейнер лога) -->
        <details class="mt-8 p-4 bg-gray-100 border border-gray-300 rounded-lg" id="debugLogSpoiler">
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-gray-700 focus:outline-none">
                <span>
                    <!-- Новая иконка: Документ/Список -->
                    <svg class="w-5 h-5 inline-block mr-2 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2m-9 0V3a1 1 0 011-1h4a1 1 0 011 1v2M9 5h6m-6 4h6m-6 4h6m-6 4h6" />
                    </svg>
                    Лог конвертации
                </span>
                <svg class="w-4 h-4 text-gray-500 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            <!-- Контейнер лога: p-2 для минимального, но достаточного отступа -->
            <div id="logDetails" class="mt-2 text-sm text-gray-700 overflow-auto h-40 bg-white p-2 rounded-lg border border-gray-200 shadow-inner">
                <!-- Log entries will appear here as structured HTML -->
            </div>
        </details>

        <!-- Footer Section with Copyright -->
        <footer class="mt-10 pt-6 border-t border-gray-200 text-center">
            <p class="text-xs text-gray-400">
                Разработано Службой испытаний, экспертизы и метрологии ГАУ ИНПЦ "Гормедтехника".
            </p>
        </footer>
    </div>

    <script>
        // --- КОНФИГУРАЦИЯ ---
        const SNILS_STORAGE_KEY = 'fgis_fsa_author_snils_map'; 
        const MPI_STORAGE_KEY = 'fgis_fsa_mpi_map_grsi'; 
        const HEADER_SKIP_LINES = 2; 
        const MIN_PROCESSING_TIME = 1500; 
        const MAX_RECORDS_PER_FILE = 1000; // НОВАЯ КОНСТАНТА: Максимальное количество записей на файл

        const COL_INDEX = {
            'Author': 1,
            'Type': 3,      
            'GRSI': 4,      
            'Date': 5,
            'Suitability': 9,
            'Document': 10
        };

        // --- ГЛОБАЛЬНЫЕ ХРАНИЛИЩА ---
        let errorCount = 0;
        let authorSnilsMap = {}; 
        let mpiMonthsMap = {};  
        
        let lastCsvContent = null;
        let lastDelimiter = null;
        let lastFileNameBase = null; // Базовое имя файла без индекса
        let allProcessedRecords = []; // Хранение всех валидных записей для скачивания

        // --- ЭЛЕМЕНТЫ DOM ---
        const fileInput = document.getElementById('fileInput');
        const dropArea = document.getElementById('drop-area');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const statusMessage = document.getElementById('statusMessage');
        const downloadButton = document.getElementById('downloadButton');
        const recordCountElement = document.getElementById('recordCount');
        const processingIndicator = document.getElementById('processingIndicator');
        const debugLogSpoiler = document.getElementById('debugLogSpoiler');
        const logDetails = document.getElementById('logDetails');
        
        // НОВЫЙ ЭЛЕМЕНТ
        const splitOutputCheckbox = document.getElementById('splitOutputCheckbox');

        // Элементы для СНИЛС
        const snilsMappingForm = document.getElementById('snilsMappingForm');
        const authorNameInput = document.getElementById('authorNameInput');
        const snilsInput = document.getElementById('snilsInput');
        const mappingListContainer = document.getElementById('mappingListContainer');
        const emptyMappingMessage = document.getElementById('emptyMappingMessage');
        const missingAuthorsContainer = document.getElementById('missingAuthorsContainer');
        const missingSnilsForm = document.getElementById('missingSnilsForm');
        const saveMissingSnilsButton = document.getElementById('saveMissingSnilsButton');

        // Элементы для JSON I/O (СНИЛС)
        const exportSnilsButton = document.getElementById('exportSnilsButton');
        const importSnilsButton = document.getElementById('importSnilsButton');
        const importSnilsFile = document.getElementById('importSnilsFile');

        // Элементы для МПИ
        const mpiMappingForm = document.getElementById('mpiMappingForm');
        const instrumentTypeInput = document.getElementById('instrumentTypeInput'); 
        const mpiMonthsConfigInput = document.getElementById('mpiMonthsConfigInput');
        const mpiMappingListContainer = document.getElementById('mpiMappingListContainer');
        const emptyMpiMessage = document.getElementById('emptyMpiMessage');
        const missingMpiContainer = document.getElementById('missingMpiContainer');
        const missingMpiForm = document.getElementById('missingMpiForm');
        const saveMissingMpiButton = document.getElementById('saveMissingMpiButton');
        
        // Элементы для JSON I/O (МПИ)
        const exportMpiButton = document.getElementById('exportMpiButton');
        const importMpiButton = document.getElementById('importMpiButton');
        const importMpiFile = document.getElementById('importMpiFile');


        // --- УТИЛИТЫ И ОБЩИЕ ФУНКЦИИ ---

        function startProcessing() {
            logDetails.innerHTML = ''; 
            errorCount = 0;
            allProcessedRecords = []; // Очистка записей
            statusMessage.textContent = 'Начало обработки файла...';
            statusMessage.classList.remove('text-red-600');
            statusMessage.classList.add('text-gray-600');
            processingIndicator.classList.remove('hidden');
            downloadButton.disabled = true;
            downloadButton.classList.add('opacity-50', 'cursor-not-allowed', 'disabled:shadow-none');
            downloadButton.classList.remove('bg-emerald-500', 'hover:bg-emerald-600');
            recordCountElement.classList.add('hidden');
            missingAuthorsContainer.classList.add('hidden'); 
            missingMpiContainer.classList.add('hidden'); 
        }

        function stopProcessing() {
            processingIndicator.classList.add('hidden');
            if (errorCount > 0) {
                 debugLogSpoiler.open = true; 
            }
        }

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.className = `font-semibold text-lg mb-4 ${isError ? 'text-red-600' : 'text-gray-600'}`;
            if (isError) {
                downloadButton.disabled = true;
                downloadButton.classList.add('opacity-50', 'cursor-not-allowed', 'disabled:shadow-none');
                downloadButton.classList.remove('bg-emerald-500', 'hover:bg-emerald-600');
            }
        }

        function updateSuccess(count) {
            let message = 'Конвертация успешно завершена. Файл готов к скачиванию.';
            if (splitOutputCheckbox.checked && count > 0) {
                const numFiles = Math.ceil(count / MAX_RECORDS_PER_FILE);
                message = `Конвертация завершена. Будет загружено ${numFiles} файлов (по ${MAX_RECORDS_PER_FILE} записей).`;
            }

            updateStatus(message, false);
            downloadButton.disabled = false;
            downloadButton.classList.remove('opacity-50', 'cursor-not-allowed', 'disabled:shadow-none');
            downloadButton.classList.add('bg-emerald-500', 'hover:bg-emerald-600');
            recordCountElement.textContent = `Сконвертировано валидных записей: ${count}. Ошибок обработки строк: ${errorCount}.`;
            recordCountElement.classList.remove('hidden');
        }
        
        function logMessage(message, level = 'INFO') {
            const timestamp = new Date().toLocaleTimeString('ru-RU');
            
            let iconSvg = '';
            let textColor = 'text-gray-700';
            let levelColor = 'text-emerald-600'; 
            let levelDisplay = 'ИНФО';

            if (level === 'ERROR') {
                iconSvg = '<svg class="w-4 h-4 mr-1 flex-shrink-0 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.3 16c-.77 1.333.192 3 1.732 3z" /></svg>';
                textColor = 'text-red-700';
                levelColor = 'text-red-600';
                levelDisplay = 'ОШИБКА';
            } else if (level === 'WARN') {
                iconSvg = '<svg class="w-4 h-4 mr-1 flex-shrink-0 text-orange-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.3 16c-.77 1.333.192 3 1.732 3z" /></svg>';
                textColor = 'text-orange-700';
                levelColor = 'text-orange-600';
                levelDisplay = 'ПРЕДУПРЕЖДЕНИЕ';
            } else {
                iconSvg = '<svg class="w-4 h-4 mr-1 flex-shrink-0 text-emerald-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>';
            }

            const logEntryHtml = `
                <div class="flex items-start text-xs font-mono py-0 leading-snug">
                    ${iconSvg}
                    <span class="${levelColor} font-bold flex-shrink-0">[${timestamp}] [${levelDisplay}]:&nbsp;</span><span class="${textColor} break-words min-w-0 flex-1">${message}</span>
                </div>
            `;
            
            logDetails.innerHTML += logEntryHtml;
            logDetails.scrollTop = logDetails.scrollHeight; 
        }

        function logError(message) {
            logMessage(message, 'ERROR');
            errorCount++;
        }
        
        function hasEncodingIssues(text) {
            return text.includes('\uFFFD');
        }

        function detectDelimiter(headerLine) {
            if (!headerLine) return ',';
            const commaCount = (headerLine.match(/,/g) || []).length;
            const semicolonCount = (headerLine.match(/;/g) || []).length;

            if (semicolonCount > commaCount + 2) {
                return ';';
            }
            return ',';
        }

        function parseDate(dateStr) {
            const formats = ["YYYY-MM-DD", "DD.MM.YYYY", "DD-MM-YYYY"];
            const cleanDateStr = dateStr.trim().split(' ')[0];

            for (const format of formats) {
                const parts = cleanDateStr.match(/(\d+)/g); 
                
                if (parts && parts.length === 3) {
                    let year, month, day;

                    if (format === "YYYY-MM-DD") {
                        [year, month, day] = parts.map(Number);
                    } else { 
                        [day, month, year] = parts.map(Number);
                    }

                    // Используем T00:00:00, чтобы избежать проблем с часовыми поясами
                    const dateObj = new Date(year, month - 1, day);

                    if (dateObj.getFullYear() === year && dateObj.getMonth() === month - 1 && dateObj.getDate() === day) {
                        return dateObj;
                    }
                }
            }
            return null; 
        }

        function formatDateToISO(dateStr) {
            const dt = parseDate(dateStr);
            if (!dt) return ""; 

            const y = dt.getFullYear();
            const m = String(dt.getMonth() + 1).padStart(2, '0');
            const d = String(dt.getDate()).padStart(2, '0');
            
            return `${y}-${m}-${d}`;
        }


        /**
         * Функция расчета даты окончания поверки
         */
        function calculateDateEndVerification(dateVerificationStr, mpiMonths) {
            const dtStart = parseDate(dateVerificationStr);
            
            if (!dtStart) return ""; 

            const months = parseInt(mpiMonths, 10);
            if (isNaN(months) || months <= 0) {
                return "";
            }

            // Создаем копию даты для расчетов. Добавляем T00:00:00, чтобы сохранить локальную дату.
            const mpiDate = new Date(dtStart.getFullYear(), dtStart.getMonth(), dtStart.getDate());
            
            // 1. Добавляем количество месяцев МПИ
            mpiDate.setMonth(mpiDate.getMonth() + months);

            // 2. Вычитаем 1 день
            mpiDate.setDate(mpiDate.getDate() - 1);

            const y = mpiDate.getFullYear();
            const m = String(mpiDate.getMonth() + 1).padStart(2, '0');
            const d = String(mpiDate.getDate()).padStart(2, '0');
            
            return `${y}-${m}-${d}`;
        }
        
        function mapSuitability(suitabilityText) {
            const text = suitabilityText.trim().toLowerCase();
            if (text === "да" || text === "yes" || text === "пригоден") {
                return '1';
            }
            if (text === "нет" || text === "no" || text === "не пригоден") {
                return '2';
            }
            logMessage(`Не удалось определить пригодность для текста: "${suitabilityText}". Установлено значение по умолчанию: "Да" (1).`, 'WARN');
            return '1'; 
        }

        function generateFileNameBase() {
            const now = new Date();
            const y = String(now.getFullYear());
            const m = String(now.getMonth() + 1).padStart(2, '0');
            const d = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const mm = String(now.getMinutes()).padStart(2, '0');
            
            return `${y}${m}${d}_${hh}${mm}_fgis`;
        }
        
        function parseCsvLine(line, delimiter) {
            if (!line.trim()) return [];
            
            const fields = [];
            let currentField = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === delimiter && !inQuotes) {
                    fields.push(currentField.trim().replace(/^"|"$/g, ''));
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            fields.push(currentField.trim().replace(/^"|"$/g, ''));

            while (fields.length > 0 && fields[fields.length - 1] === '') {
                fields.pop();
            }
            return fields;
        }
        
        // General JSON download utility
        function downloadJSON(data, filename) {
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename; 
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logMessage(`JSON-файл "${filename}" создан и загружен.`);
        }


        // --- ЛОГИКА СОПОСТАВЛЕНИЙ (Без изменений) ---

        function loadMappings() {
            try {
                const storedSnils = localStorage.getItem(SNILS_STORAGE_KEY);
                if (storedSnils) {
                    authorSnilsMap = JSON.parse(storedSnils);
                    logMessage('Сопоставления СНИЛС загружены.');
                }
                const storedMpi = localStorage.getItem(MPI_STORAGE_KEY);
                 if (storedMpi) {
                    mpiMonthsMap = JSON.parse(storedMpi);
                    logMessage('Сопоставления МПИ (ГРСИ) загружены.');
                }
            } catch(e) {
                logError(`Ошибка загрузки сопоставлений из localStorage: ${e.message}`);
                authorSnilsMap = {};
                mpiMonthsMap = {};
            }
            renderMappings();
            renderMpiMappings();
        }

        function saveAndRenderMappings() {
            try {
                localStorage.setItem(SNILS_STORAGE_KEY, JSON.stringify(authorSnilsMap));
                logMessage('Сопоставления СНИЛС сохранены.');
            } catch(e) {
                logError(`Ошибка сохранения сопоставлений СНИЛС: ${e.message}`);
            }
            renderMappings();
        }
        
        function saveAndRenderMpiMappings() {
            try {
                localStorage.setItem(MPI_STORAGE_KEY, JSON.stringify(mpiMonthsMap));
                logMessage('Сопоставления МПИ (ГРСИ) сохранены.');
            } catch(e) {
                logError(`Ошибка сохранения сопоставлений МПИ: ${e.message}`);
            }
            renderMpiMappings();
        }
        
        // ... (renderMappings, renderMpiMappings, handleMappingForm, handleMpiMappingForm, handleDeleteMapping, handleDeleteMpiMapping, exportSnilsMap, importSnilsMapHandler, exportMpiMap, importMpiMapHandler - ОСТАВЛЕНО БЕЗ ИЗМЕНЕНИЙ ИЗ-ЗА ДЛИНЫ) ...
        // ВАЖНО: Функции renderMappings и renderMpiMappings и их хэндлеры (добавление/удаление) остаются без изменений.

        // ... (checkAndDisplayMissingAuthors, checkAndDisplayMissingMpi, handleMissingSnilsSubmission, handleMissingMpiSubmission - ОСТАВЛЕНО БЕЗ ИЗМЕНЕНИЙ ИЗ-ЗА ДЛИНЫ) ...

        function renderMappings() {
            const authors = Object.keys(authorSnilsMap).sort();
            mappingListContainer.innerHTML = ''; 
            
            if (authors.length === 0) {
                mappingListContainer.appendChild(emptyMappingMessage);
                emptyMappingMessage.classList.remove('hidden');
                return;
            }

            emptyMappingMessage.classList.add('hidden');

            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-gray-200';
            table.innerHTML = `
                <thead class="bg-gray-200 sticky top-0">
                    <tr>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ФИО</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">СНИЛС</th>
                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Действие</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-100" id="mappingTableBody">
                </tbody>
            `;
            mappingListContainer.appendChild(table);
            const tbody = document.getElementById('mappingTableBody');

            authors.forEach(author => {
                const snils = authorSnilsMap[author];
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50 transition duration-100';
                tr.innerHTML = `
                    <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">${author}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500">${snils}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-right text-sm font-medium">
                        <button data-author="${author}" class="delete-snils-btn text-red-600 hover:text-red-900 transition duration-150">
                            Удалить
                        </button>
                    </td>
                `;
                tbody.appendChild(tr);
            });

            tbody.querySelectorAll('.delete-snils-btn').forEach(button => {
                button.addEventListener('click', handleDeleteMapping);
            });
        }
        
        function renderMpiMappings() {
            const grsiNumbers = Object.keys(mpiMonthsMap).sort();
            mpiMappingListContainer.innerHTML = ''; 
            
            if (grsiNumbers.length === 0) {
                mpiMappingListContainer.appendChild(emptyMpiMessage);
                emptyMpiMessage.classList.remove('hidden');
                return;
            }

            emptyMpiMessage.classList.add('hidden');

            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-gray-200';
            table.innerHTML = `
                <thead class="bg-gray-200 sticky top-0">
                    <tr>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Номер ГРСИ</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">МПИ (мес.)</th>
                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Действие</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-100" id="mpiMappingTableBody">
                </tbody>
            `;
            mpiMappingListContainer.appendChild(table);
            const tbody = document.getElementById('mpiMappingTableBody');

            grsiNumbers.forEach(grsi => {
                const mpi = mpiMonthsMap[grsi];
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50 transition duration-100';
                tr.innerHTML = `
                    <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">${grsi}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500">${mpi}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-right text-sm font-medium">
                        <button data-type="${grsi}" class="delete-mpi-btn text-red-600 hover:text-red-900 transition duration-150">
                            Удалить
                        </button>
                    </td>
                `;
                tbody.appendChild(tr);
            });

            tbody.querySelectorAll('.delete-mpi-btn').forEach(button => {
                button.addEventListener('click', handleDeleteMpiMapping);
            });
        }

        function handleMappingForm(e) {
            e.preventDefault();
            const author = authorNameInput.value.trim();
            const snils = snilsInput.value.trim();

            if (author && snils.match(/^\d{11}$/)) {
                authorSnilsMap[author] = snils;
                logMessage(`СНИЛС сопоставление добавлено/обновлено: ${author} -> ${snils}`);
                saveAndRenderMappings();
                authorNameInput.value = '';
                snilsInput.value = '';
            } else {
                 logError('Ошибка: Проверьте правильность ФИО автора и СНИЛС (11 цифр).');
            }
        }
        
        function handleMpiMappingForm(e) {
            e.preventDefault();
            const grsiNumber = instrumentTypeInput.value.trim(); // Номер ГРСИ
            const mpi = mpiMonthsConfigInput.value.trim();
            const mpiInt = parseInt(mpi, 10);

            if (grsiNumber && !isNaN(mpiInt) && mpiInt > 0) {
                mpiMonthsMap[grsiNumber] = mpiInt;
                logMessage(`МПИ сопоставление добавлено/обновлено: ГРСИ №${grsiNumber} -> ${mpiInt} мес.`);
                saveAndRenderMpiMappings();
                instrumentTypeInput.value = '';
                mpiMonthsConfigInput.value = '';
            } else {
                 logError('Ошибка: Проверьте правильность Номера ГРСИ и МПИ (должно быть целое число месяцев > 0).');
            }
        }

        function handleDeleteMapping(e) {
            const author = e.target.dataset.author;
            if (author in authorSnilsMap) {
                delete authorSnilsMap[author];
                logMessage(`Сопоставление СНИЛС удалено для автора: ${author}`);
                saveAndRenderMappings();
            }
        }
        
        function handleDeleteMpiMapping(e) {
            const grsi = e.target.dataset.type; // data-type содержит номер ГРСИ
            if (grsi in mpiMonthsMap) {
                delete mpiMonthsMap[grsi];
                logMessage(`Сопоставление МПИ удалено для ГРСИ №: ${grsi}`);
                saveAndRenderMpiMappings();
            }
        }
        
        function exportSnilsMap() {
            if (Object.keys(authorSnilsMap).length === 0) {
                logError('Нечего экспортировать: Сопоставления СНИЛС пусты.');
                return;
            }
            const filename = `snils_map_export_${new Date().toISOString().slice(0, 10)}.json`;
            downloadJSON(authorSnilsMap, filename);
        }
        
        function importSnilsMapHandler(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedMap = JSON.parse(e.target.result);
                    if (typeof importedMap !== 'object' || Array.isArray(importedMap)) {
                        logError('Ошибка импорта СНИЛС: Файл имеет неверный формат (ожидается объект {author: snils}).');
                        return;
                    }
                    
                    let newCount = 0;
                    let totalCount = 0;
                    for (const key in importedMap) {
                        if (importedMap.hasOwnProperty(key)) {
                            const snils = String(importedMap[key]).trim();
                            if (snils.match(/^\d{11}$/)) {
                                if (authorSnilsMap[key] !== snils) {
                                     newCount++;
                                }
                                authorSnilsMap[key] = snils;
                                totalCount++;
                            } else {
                                logError(`Импорт СНИЛС: Пропущено невалидное значение для ключа "${key}".`);
                            }
                        }
                    }
                    if (totalCount > 0) {
                        saveAndRenderMappings();
                        logMessage(`Успешно импортировано ${totalCount} записей СНИЛС. Новых/обновленных: ${newCount}.`);
                    } else {
                         logError('Ошибка импорта СНИЛС: В файле не найдено валидных записей.');
                    }

                } catch (error) {
                    logError(`Ошибка разбора JSON при импорте СНИЛС: ${error.message}`);
                }
            };
            reader.onerror = () => logError('Ошибка чтения файла при импорте СНИЛС.');
            reader.readAsText(file);
        }
        
        function exportMpiMap() {
            if (Object.keys(mpiMonthsMap).length === 0) {
                logError('Нечего экспортировать: Сопоставления МПИ пусты.');
                return;
            }
            const filename = `mpi_map_export_${new Date().toISOString().slice(0, 10)}.json`;
            downloadJSON(mpiMonthsMap, filename);
        }
        
        function importMpiMapHandler(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedMap = JSON.parse(e.target.result);
                    if (typeof importedMap !== 'object' || Array.isArray(importedMap)) {
                        logError('Ошибка импорта МПИ: Файл имеет неверный формат (ожидается объект {grsi_number: mpi_months}).');
                        return;
                    }

                    let newCount = 0;
                    let totalCount = 0;
                    for (const key in importedMap) {
                        if (importedMap.hasOwnProperty(key)) {
                            const mpi = parseInt(importedMap[key], 10);
                            if (!isNaN(mpi) && mpi > 0) {
                                if (mpiMonthsMap[key] !== mpi) {
                                    newCount++;
                                }
                                mpiMonthsMap[key] = mpi;
                                totalCount++;
                            } else {
                                logError(`Импорт МПИ: Пропущено невалидное значение МПИ для ГРСИ №"${key}".`);
                            }
                        }
                    }
                    
                    if (totalCount > 0) {
                        saveAndRenderMpiMappings();
                        logMessage(`Успешно импортировано ${totalCount} записей МПИ. Новых/обновленных: ${newCount}.`);
                    } else {
                         logError('Ошибка импорта МПИ: В файле не найдено валидных записей.');
                    }
                    
                } catch (error) {
                    logError(`Ошибка разбора JSON при импорте МПИ: ${error.message}`);
                }
            };
            reader.onerror = () => logError('Ошибка чтения файла при импорте МПИ.');
            reader.readAsText(file);
        }

        
        function getUniqueValuesFromCsv(csvContent, delimiter, colIndex) {
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            if (lines.length <= HEADER_SKIP_LINES + 1) return new Set();

            const dataLines = lines.slice(HEADER_SKIP_LINES + 1);
            const uniqueValues = new Set();
            
            dataLines.forEach((line) => {
                const fields = parseCsvLine(line, delimiter);
                if (fields.length > colIndex) {
                    const value = fields[colIndex].trim();
                    if (value) uniqueValues.add(value);
                }
            });
            return uniqueValues;
        }

        function checkAndDisplayMissingAuthors(uniqueAuthors) {
            const missingAuthors = [];
            uniqueAuthors.forEach(author => {
                if (!(author in authorSnilsMap)) {
                    missingAuthors.push(author);
                }
            });

            if (missingAuthors.length > 0) {
                missingAuthorsContainer.classList.remove('hidden');
                logError(`Обнаружено ${missingAuthors.length} уникальных авторов без сопоставления СНИЛС.`);
                
                missingSnilsForm.innerHTML = ''; 
                missingAuthors.forEach(author => {
                    const div = document.createElement('div');
                    div.className = 'flex flex-col sm:flex-row items-center gap-2 bg-white p-2 rounded shadow-sm border border-red-200';
                    div.innerHTML = `
                        <span class="font-medium text-gray-800 text-sm w-full sm:w-2/5 truncate" title="${author}">${author}</span>
                        <input type="text" data-author="${author}" placeholder="СНИЛС (11 цифр)" pattern="^\\d{11}$"
                               class="snils-input flex-1 p-1 border border-gray-300 rounded text-sm w-full" autocomplete="off">
                    `;
                    missingSnilsForm.appendChild(div);
                });
                saveMissingSnilsButton.onclick = handleMissingSnilsSubmission;
                return true; 
            } else {
                missingAuthorsContainer.classList.add('hidden');
                logMessage('Все авторы из файла успешно сопоставлены с данными СНИЛС.');
                return false;
            }
        }
        
        function checkAndDisplayMissingMpi(csvContent, usedDelimiter) {
            const uniqueGrsiNumbers = getUniqueValuesFromCsv(csvContent, usedDelimiter, COL_INDEX.GRSI);
            
            const missingGrsi = [];
            uniqueGrsiNumbers.forEach(grsi => {
                if (!(grsi in mpiMonthsMap)) {
                    missingGrsi.push(grsi);
                }
            });

            if (missingGrsi.length > 0) {
                missingMpiContainer.classList.remove('hidden');
                logError(`Обнаружено ${missingGrsi.length} уникальных номеров ГРСИ без сопоставления МПИ.`);
                
                missingMpiForm.innerHTML = ''; 
                missingGrsi.forEach(grsi => {
                    const div = document.createElement('div');
                    div.className = 'flex flex-col sm:flex-row items-center gap-2 bg-white p-2 rounded shadow-sm border border-orange-200';
                    div.innerHTML = `
                        <span class="font-medium text-gray-800 text-sm w-full sm:w-2/5 truncate" title="${grsi}">ГРСИ №: ${grsi}</span>
                        <input type="number" data-type="${grsi}" placeholder="МПИ (месяцы)" min="1"
                               class="mpi-input flex-1 p-1 border border-gray-300 rounded text-sm w-full" autocomplete="off">
                    `;
                    missingMpiForm.appendChild(div);
                });
                saveMissingMpiButton.onclick = handleMissingMpiSubmission;
                return true; 
            } else {
                missingMpiContainer.classList.add('hidden');
                logMessage('Все номера ГРСИ из файла успешно сопоставлены с данными МПИ.');
                return false;
            }
        }

        function handleMissingSnilsSubmission(e) {
            e.preventDefault();
            const inputs = missingSnilsForm.querySelectorAll('.snils-input');
            let newMappingsCount = 0;
            let errorFound = false;

            inputs.forEach(input => {
                const author = input.dataset.author;
                const snils = input.value.trim();

                input.classList.remove('border-red-500', 'bg-red-50', 'border-emerald-500', 'bg-emerald-50');
                
                if (snils.length > 0) {
                    if (snils.match(/^\d{11}$/)) {
                        if (!(author in authorSnilsMap) || authorSnilsMap[author] !== snils) {
                            authorSnilsMap[author] = snils;
                            newMappingsCount++;
                        }
                        input.classList.add('border-emerald-500', 'bg-emerald-50');
                        input.disabled = true; 
                    } else {
                        logError(`Некорректный СНИЛС для "${author}". Ожидается 11 цифр.`);
                        input.classList.add('border-red-500', 'bg-red-50');
                        errorFound = true;
                    }
                }
            });

            if (errorFound) {
                logMessage('Не все СНИЛС сохранены из-за ошибок валидации. Исправьте выделенные поля.', 'ERROR');
                return;
            }

            if (newMappingsCount > 0) {
                saveAndRenderMappings();
                logMessage(`Успешно добавлено/обновлено ${newMappingsCount} сопоставлений СНИЛС.`);
            } else {
                logMessage('Нет новых данных СНИЛС для сохранения.');
            }
            
            if (errorFound === false) {
                 missingAuthorsContainer.classList.add('hidden');
                 if (lastCsvContent && lastDelimiter) {
                     logMessage('Все недостающие СНИЛС сохранены. Автоматический перезапуск конвертации...');
                     runConversionProcess(lastCsvContent, lastDelimiter);
                 } else {
                     updateStatus('Сопоставления СНИЛС обновлены. Загрузите CSV-файл для конвертации.');
                 }
            }
        }
        
        function handleMissingMpiSubmission(e) {
            e.preventDefault();
            const inputs = missingMpiForm.querySelectorAll('.mpi-input');
            let newMappingsCount = 0;
            let errorFound = false;

            inputs.forEach(input => {
                const grsiNumber = input.dataset.type; 
                const mpi = parseInt(input.value.trim(), 10);

                input.classList.remove('border-red-500', 'bg-red-50', 'border-emerald-500', 'bg-emerald-50');
                
                if (!isNaN(mpi)) {
                    if (mpi > 0) {
                        if (mpiMonthsMap[grsiNumber] !== mpi) {
                            mpiMonthsMap[grsiNumber] = mpi;
                            newMappingsCount++;
                        }
                        input.classList.add('border-emerald-500', 'bg-emerald-50');
                        input.disabled = true; 
                    } else {
                        logError(`Некорректный МПИ для ГРСИ №${grsiNumber}. Ожидается целое число месяцев > 0.`);
                        input.classList.add('border-red-500', 'bg-red-50');
                        errorFound = true;
                    }
                }
            });

            if (errorFound) {
                logMessage('Не все МПИ сохранены из-за ошибок валидации. Исправьте выделенные поля.', 'ERROR');
                return;
            }

            if (newMappingsCount > 0) {
                saveAndRenderMpiMappings();
                logMessage(`Успешно добавлено/обновлено ${newMappingsCount} сопоставлений МПИ.`);
            } else {
                logMessage('Нет новых данных МПИ для сохранения.');
            }
            
            if (errorFound === false) {
                 missingMpiContainer.classList.add('hidden');
                 if (lastCsvContent && lastDelimiter) {
                     logMessage('Все недостающие МПИ сохранены. Автоматический перезапуск конвертации...');
                     runConversionProcess(lastCsvContent, lastDelimiter);
                 } else {
                     updateStatus('Сопоставления МПИ обновлены. Загрузите CSV-файл для конвертации.');
                 }
            }
        }

        // --- ОСНОВНАЯ ЛОГИКА КОНВЕРТАЦИИ ---
        
        /**
         * Runs the full conversion process with pre-loaded content.
         * @param {string} csvContent - Full content of the CSV file.
         * @param {string} usedDelimiter - Delimiter used in the CSV.
         */
        async function runConversionProcess(csvContent, usedDelimiter) {
            startProcessing(); 
            const startTime = performance.now();
            
            try {
                const uniqueAuthors = getUniqueValuesFromCsv(csvContent, usedDelimiter, COL_INDEX.Author);

                const missingSnils = checkAndDisplayMissingAuthors(uniqueAuthors);
                const missingMpi = checkAndDisplayMissingMpi(csvContent, usedDelimiter);
                
                if (missingSnils || missingMpi) {
                    throw new Error("Требуется ввод недостающих данных (СНИЛС или МПИ). Исправьте выделенные блоки.");
                }
                
                // --- 3. Парсинг и фильтрация всех валидных записей ---
                allProcessedRecords = parseAndValidateRecords(csvContent, usedDelimiter);
                
                if (allProcessedRecords.length === 0) {
                    throw new Error("Ошибка: Не найдено валидных записей для конвертации. Проверьте лог отладки.");
                }
                
                // --- 4. Завершение ---
                const elapsedTime = performance.now() - startTime;
                const delay = Math.max(0, MIN_PROCESSING_TIME - elapsedTime);

                setTimeout(() => {
                    stopProcessing();
                    updateSuccess(allProcessedRecords.length);
                    
                    // Назначаем обработчик скачивания
                    downloadButton.onclick = handleDownload;
                }, delay);

            } catch(e) {
                 const errorMessage = e.message.startsWith("Требуется ввод") ? e.message : `Критическая ошибка обработки данных: ${e.message}`;
                 logError(`КРИТИЧЕСКАЯ ОШИБКА В КОНВЕРТАЦИИ: ${errorMessage}`);
                 updateStatus(errorMessage, true);
                 stopProcessing();
            }
        }
        
        /**
         * Парсит CSV, валидирует, применяет сопоставления и возвращает массив готовых объектов для XML.
         * @returns {Array<Object>} Массив валидных записей с готовыми полями для XML.
         */
        function parseAndValidateRecords(csvContent, usedDelimiter) {
            logMessage('Начало парсинга и валидации записей...');
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            const csvTextWithHeader = lines.slice(HEADER_SKIP_LINES);
            const dataLines = csvTextWithHeader.slice(1); 
            
            const dataRecords = dataLines.map((line) => parseCsvLine(line, usedDelimiter)).filter(fields => fields.length > 0); 
            
            logMessage(`Найдено ${dataRecords.length} потенциальных строк для конвертации.`);

            const validRecords = [];
            
            for (let i = 0; i < dataRecords.length; i++) {
                const fields = dataRecords[i];
                const lineNumber = i + HEADER_SKIP_LINES + 2; 

                if (fields.length < COL_INDEX.Document + 1 || fields.length < COL_INDEX.GRSI + 1) {
                     logError(`Строка ${lineNumber}: Пропущена: недостаточно столбцов.`);
                     continue;
                }

                try {
                    const authorFull = fields[COL_INDEX.Author].trim();
                    const documentNum = fields[COL_INDEX.Document];

                    if (!documentNum || documentNum.trim() === '') {
                        logError(`Строка ${lineNumber} (${documentNum}): Пропущена, отсутствует номер документа (колонка ${COL_INDEX.Document}).`);
                        continue;
                    }
                    
                    const snils = authorSnilsMap[authorFull];
                    const grsiNumber = fields[COL_INDEX.GRSI].trim();         
                    const mpiMonths = mpiMonthsMap[grsiNumber];
                    
                    // Эти проверки должны были быть сделаны до вызова, но дублируем для безопасности
                    if (!snils) { logError(`Строка ${lineNumber} (${documentNum}): Отсутствует сопоставление СНИЛС для автора: "${authorFull}".`); continue; }
                    if (!mpiMonths) { logError(`Строка ${lineNumber} (${documentNum}): Отсутствует сопоставление МПИ для ГРСИ №: "${grsiNumber}".`); continue; }


                    // --- Валидация и Форматирование ---
                    const dateVerification = fields[COL_INDEX.Date];
                    const dateVerificationClean = dateVerification.split(' ')[0];
                    const formattedDateVerification = formatDateToISO(dateVerificationClean);
                    
                    if (formattedDateVerification === "") {
                         logError(`Строка ${lineNumber} (${documentNum}): Не удалось преобразовать дату "${dateVerificationClean}".`);
                         continue;
                    }
                    
                    const dateEndVerification = calculateDateEndVerification(dateVerificationClean, mpiMonths);
                    const resultVerification = mapSuitability(fields[COL_INDEX.Suitability]);
                    
                    // Разделение ФИО
                    const authorParts = authorFull.split(/\s+/).filter(p => p.length > 0);
                    const lastName = authorParts[0] || "Неизвестный";
                    const firstName = authorParts.slice(1).join(' ') || "Автор";
                    
                    // Сохраняем готовую запись
                    validRecords.push({
                        lineNumber,
                        documentNum,
                        typeInstrument: fields[COL_INDEX.Type].trim(),
                        formattedDateVerification,
                        dateEndVerification,
                        resultVerification,
                        lastName,
                        firstName,
                        snils
                    });

                } catch (e) {
                    logError(`Строка ${lineNumber}: Критическая ошибка обработки: ${e.message}.`);
                }
            }
            
            logMessage(`Парсинг завершен. Всего валидных записей: ${validRecords.length}.`);
            return validRecords;
        }

        /**
         * Генерирует XML-контент для заданного массива записей.
         * @param {Array<Object>} records - Массив записей, возвращенный parseAndValidateRecords.
         * @returns {string} Готовая XML-строка.
         */
        function generateXmlContent(records) {
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<Message xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="schema.xsd">\n';
            xml += '    <VerificationMeasuringInstrumentData>\n';
            
            const escape = (str) => str ? str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;') : '';

            records.forEach(record => {
                xml += '        <VerificationMeasuringInstrument>\n';
                xml += `            <NumberVerification>${escape(record.documentNum)}</NumberVerification>\n`;
                xml += `            <DateVerification>${escape(record.formattedDateVerification)}</DateVerification>\n`;
                
                if (record.resultVerification === '1' && record.dateEndVerification) {
                    xml += `            <DateEndVerification>${escape(record.dateEndVerification)}</DateEndVerification>\n`;
                } else if (record.resultVerification === '1' && !record.dateEndVerification) {
                    logMessage(`Строка ${record.lineNumber} (${record.documentNum}): Не удалось рассчитать DateEndVerification. Поле пропущено.`, 'WARN');
                }
                
                xml += `            <TypeMeasuringInstrument>${escape(record.typeInstrument)}</TypeMeasuringInstrument>\n`;
                xml += '            <ApprovedEmployees>\n';
                xml += '                <Name>\n';
                xml += `                    <Last>${escape(record.lastName)}</Last>\n`;
                xml += `                    <First>${escape(record.firstName)}</First>\n`;
                xml += '                </Name>\n';
                xml += `                <SNILS>${escape(record.snils)}</SNILS>\n`;
                xml += '            </ApprovedEmployees>\n';
                xml += `            <ResultVerification>${record.resultVerification}</ResultVerification>\n`;
                xml += '        </VerificationMeasuringInstrument>\n';
            });

            xml += '    </VerificationMeasuringInstrumentData>\n';
            xml += '    <SaveMethod>2</SaveMethod>\n';
            xml += '</Message>';

            return xml;
        }

        /**
         * Загрузка одного файла.
         */
        function downloadXML(xmlContent, filename) {
            const blob = new Blob([xmlContent], { type: 'text/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename; 
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logMessage(`XML-файл "${filename}" создан и загружен.`);
        }
        
        /**
         * НОВЫЙ ХЕНДЛЕР СКАЧИВАНИЯ, УЧИТЫВАЮЩИЙ РАЗДЕЛЕНИЕ.
         */
        function handleDownload() {
            if (!allProcessedRecords || allProcessedRecords.length === 0) {
                logError('Нет данных для скачивания.');
                return;
            }
            
            const shouldSplit = splitOutputCheckbox.checked;
            const filenameBase = lastFileNameBase;
            const records = allProcessedRecords;
            const totalRecords = records.length;
            
            downloadButton.disabled = true; // Отключаем кнопку на время загрузки
            downloadButton.textContent = shouldSplit ? 'Начало загрузки...' : 'Скачивание...';

            if (shouldSplit) {
                // Логика разделения и последовательной загрузки
                const numChunks = Math.ceil(totalRecords / MAX_RECORDS_PER_FILE);
                logMessage(`Разделение на ${numChunks} файлов по ${MAX_RECORDS_PER_FILE} записей.`);
                
                let currentChunk = 0;
                
                function downloadNextChunk() {
                    if (currentChunk < numChunks) {
                        const start = currentChunk * MAX_RECORDS_PER_FILE;
                        const end = Math.min(start + MAX_RECORDS_PER_FILE, totalRecords);
                        const chunkRecords = records.slice(start, end);
                        
                        const chunkXml = generateXmlContent(chunkRecords);
                        const filename = `${filenameBase}_part_${currentChunk + 1}-of-${numChunks}.xml`;
                        
                        // Используем setTimeout(0) для асинхронного скачивания, чтобы избежать блокировки
                        setTimeout(() => {
                            downloadXML(chunkXml, filename);
                            downloadButton.textContent = `Загрузка файла ${currentChunk + 1} из ${numChunks}...`;
                            currentChunk++;
                            downloadNextChunk(); // Рекурсивный вызов для следующего файла
                        }, 500); // Небольшая задержка, чтобы помочь браузеру обработать множественные запросы
                    } else {
                        logMessage('Все части XML-файлов успешно загружены.');
                        downloadButton.disabled = false;
                        downloadButton.textContent = 'Скачать XML-файл';
                    }
                }
                
                downloadNextChunk();

            } else {
                // Логика загрузки одного файла
                const finalXmlContent = generateXmlContent(records);
                const filename = `${filenameBase}.xml`;
                
                downloadXML(finalXmlContent, filename);
                
                downloadButton.disabled = false;
                downloadButton.textContent = 'Скачать XML-файл';
            }
        }
        
        function readFileWithEncoding(file, encoding) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file, encoding);
            });
        }

        // --- ОБРАБОТЧИКИ СОБЫТИЙ ---

        async function handleFiles(files) {
            if (files.length === 0) return;

            const file = files[0];
            if (!file.name.toLowerCase().endsWith('.csv')) {
                updateStatus("Ошибка: Пожалуйста, выберите файл CSV.", true);
                logError(`Выбран не CSV файл: ${file.name}`);
                return;
            }

            fileNameDisplay.textContent = `Выбран файл: ${file.name}`;
            startProcessing();

            let csvContent = null;
            let usedDelimiter = null;

            try {
                logMessage('Чтение файла с автоопределением кодировки...');
                let content = await readFileWithEncoding(file, 'UTF-8');
                
                if (hasEncodingIssues(content)) {
                    content = await readFileWithEncoding(file, 'windows-1251');
                    logMessage(`Файл успешно прочитан с использованием кодировки Windows-1251.`);
                } else {
                    logMessage('Файл успешно прочитан с кодировкой UTF-8.');
                }
                csvContent = content;
                usedDelimiter = detectDelimiter(csvContent.split('\n')[HEADER_SKIP_LINES]);

                // --- Сохраняем для автоперезапуска и для проверки отсутствующих данных ---
                lastCsvContent = csvContent;
                lastDelimiter = usedDelimiter;
                lastFileNameBase = generateFileNameBase(); // Генерируем базовое имя файла

                
                // --- 2. Запуск процесса (который теперь включает проверку отсутствующих данных) ---
                await runConversionProcess(lastCsvContent, lastDelimiter);

            } catch(e) {
                 const errorMessage = `Критическая ошибка чтения файла: ${e.message}`;
                 logError(errorMessage);
                 updateStatus(errorMessage, true);
                 stopProcessing();
            }
        }

        // Drop Area Events
        dropArea.addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
            e.target.value = null; 
        });

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('active'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('active'), false);
        });

        dropArea.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }, false);

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // --- Прикрепление обработчиков форм и JSON I/O ---
        snilsMappingForm.addEventListener('submit', handleMappingForm);
        mpiMappingForm.addEventListener('submit', handleMpiMappingForm);

        // JSON I/O Handlers
        exportSnilsButton.addEventListener('click', exportSnilsMap);
        importSnilsButton.addEventListener('click', () => importSnilsFile.click());
        importSnilsFile.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importSnilsMapHandler(e.target.files[0]);
            }
            e.target.value = null; 
        });

        exportMpiButton.addEventListener('click', exportMpiMap);
        importMpiButton.addEventListener('click', () => importMpiFile.click());
        importMpiFile.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importMpiMapHandler(e.target.files[0]);
            }
            e.target.value = null; 
        });
        
        // --- НОВЫЙ ХЕНДЛЕР: Перезапуск конвертации при смене опции разделения, если файл уже загружен ---
        splitOutputCheckbox.addEventListener('change', () => {
             if (allProcessedRecords.length > 0) {
                 updateSuccess(allProcessedRecords.length);
             }
        });


        // Инициализация
        loadMappings(); 
        updateStatus("Готов к работе!");
    </script>
</body>
</html>
