<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Конвертер данных для ФГИС ФСА</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; 
            min-height: 100vh;
            background-image: linear-gradient(0deg, transparent 14px, rgba(160, 174, 192, 0.15) 15px),
                              linear-gradient(90deg, transparent 14px, rgba(160, 174, 192, 0.15) 15px);
            background-size: 15px 15px; 
            background-attachment: fixed;
        }
        
        /* Главная карточка */
        .main-card {
            background-color: #ffffff;
        }

        .drag-area {
            border: 3px dashed #94a3b8; /* slate-400 */
            transition: all 0.3s ease;
        }
        .drag-area.active {
            border-color: #0ea5e9; /* sky-500 */
            background-color: #f0f9ff; /* sky-50 */
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.2); /* ring effect for focus */
        }
        
        details[open] summary svg {
            transform: rotate(180deg);
        }
        
        /* Анимация полос прогресса */
        @keyframes progress-stripes {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .animate-progress-stripes {
            width: 200%; 
            animation: progress-stripes 2s linear infinite;
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.15) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.15) 50%,
                rgba(255, 255, 255, 0.15) 75%,
                transparent 75%,
                transparent
            );
            background-size: 1rem 1rem;
            will-change: transform;
        }
        
        .snils-input:focus, .mpi-input:focus {
             outline: none;
             border-color: #f97316; /* orange-500 */
             box-shadow: 0 0 0 1px #f97316;
        }
        
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'accent-sky': '#0ea5e9', // sky-500 for primary
                        'accent-emerald': '#10b981', // emerald-500 for success
                    }
                }
            }
        }
    </script>
</head>
<body class="p-4 md:p-12">

    <!-- Главная карточка - чистая, белая, с акцентной рамкой -->
    <div class="max-w-4xl mx-auto main-card p-6 md:p-10 rounded-xl shadow-xl border-t-4 border-accent-sky">
        <header class="mb-8 border-b border-gray-200 pb-4">
            <h1 class="text-3xl font-bold text-gray-800 mb-1">
                <span class="text-accent-sky">|</span> Конвертер данных <span class="text-accent-sky">ФГИС</span>
            </h1>
            <p class="text-gray-500 text-base">
                Преобразование выгрузки "АРШИН" в формат для загрузки в ФГИС ФСА.
            </p>
        </header>

        <!-- Instruction Guide Block -->
        <details class="mb-8 p-4 bg-sky-50 border border-sky-200 rounded-lg">
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-sky-800 focus:outline-none">
                <span>
                    <svg class="w-5 h-5 inline-block mr-2 text-sky-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    Инструкция по подготовке файла (ВАЖНО)
                </span>
                <svg class="w-4 h-4 text-sky-600 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            
            <div class="mt-3 text-sm text-gray-700 space-y-3">
                <p class="font-bold text-sky-900">1. Проверка структуры файла:</p>
                <p>Ваш файл должен быть экспортирован из реестра таким образом, чтобы заголовок таблицы начинался с <span class="font-mono bg-sky-100 p-1 rounded">3-й строки</span> (первые две строки – это метаданные, которые конвертер автоматически пропустит).</p>
                
                <p class="font-bold text-sky-900">2. Обязательные колонки (Индекс = номер колонки, начиная с 0):</p>
                <ul class="list-disc list-inside ml-4 space-y-1 bg-white p-3 rounded border">
                    <li><span class="font-mono">Author</span> (Индекс **1**): ФИО автора записи. **Требуется сопоставление СНИЛС.**</li>
                    <li><span class="font-mono">Type</span> (Индекс **3**): Наименование типа СИ. (Используется для тега TypeMeasuringInstrument в XML)</li>
                    <li><span class="font-mono">GRSI</span> (Индекс **4**): Номер записи в ГРСИ. **Требуется сопоставление МПИ.**</li>
                    <li><span class="font-mono">Date</span> (Индекс **5**): Дата поверки.</li>
                    <li><span class="font-mono">Suitability</span> (Индекс **9**): Пригодность ("Да" или "Нет").</li>
                    <li><span class="font-mono">Document</span> (Индекс **10**): Номер документа (протокола) поверки.</li>
                </ul>
                
                <p class="font-bold text-sky-900">3. Сохранение в формат CSV:</p>
                <p>В Excel выберите "Сохранить как" и выберите тип файла <span class="font-medium">CSV (разделители-запятые)</span> или <span class="font-medium">CSV (разделители-точки с запятой)</span>. Конвертер автоматически определит разделитель.</p>
                
                <p class="text-xs italic mt-4 text-sky-700">
                    <span class="font-semibold">Расчет МПИ:</span> Дата окончания поверки рассчитывается как (Дата Поверки + МПИ в месяцах - 1 день).
                </p>
            </div>
        </details>
        
        <!-- Input and Status Section -->
        <div class="space-y-6">
            
            <!-- БЛОК 1: Загрузка файла (Drag-n-Drop) -->
            <div>
                <h2 class="text-xl font-semibold text-gray-700 mb-3 border-b pb-1">
                    Загрузка исходного CSV
                </h2>
                <div id="drop-area" class="drag-area p-8 rounded-lg text-center cursor-pointer transition-all hover:ring-2 hover:ring-offset-2 hover:ring-sky-300">
                    <input type="file" id="fileInput" accept=".csv" class="hidden">
                    <svg class="mx-auto h-12 w-12 text-accent-sky" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 014 4v2a4 4 0 01-4 4H7z" />
                    </svg>
                    <p class="mt-2 text-sm text-gray-600">
                        Перетащите CSV-файл сюда или <span class="text-accent-sky font-semibold">нажмите для выбора</span>
                    </p>
                    <p id="fileNameDisplay" class="text-xs text-gray-400 mt-1"></p>
                </div>
            </div>
            
            <!-- БЛОК ПРЕДУПРЕЖДЕНИЯ О НЕДОСТАЮЩИХ АВТОРАХ (СНИЛС) -->
            <div id="missingAuthorsContainer" class="hidden p-4 bg-red-100 border-l-4 border-red-500 rounded-lg shadow-md">
                <div class="flex items-start">
                    <svg class="h-6 w-6 text-red-600 mt-1 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.3 16c-.77 1.333.192 3 1.732 3z" />
                    </svg>
                    <div class="ml-3 w-full">
                        <h3 class="text-lg font-semibold text-red-800">
                            Обнаружены недостающие СНИЛС!
                        </h3>
                        <p class="mt-1 text-sm text-red-700">
                            Введите СНИЛС для следующих авторов, чтобы не пропускать их записи.
                        </p>
                        <!-- ДИНАМИЧЕСКАЯ ФОРМА ДЛЯ БЫСТРОГО ВВОДА СНИЛС -->
                        <form id="missingSnilsForm" class="mt-2 text-sm bg-red-50 p-3 rounded max-h-56 overflow-y-auto space-y-2">
                            <!-- Список авторов и полей ввода будет сгенерирован здесь -->
                        </form>
                        <button id="saveMissingSnilsButton" class="w-full mt-3 bg-red-600 text-white font-bold py-2 rounded-lg hover:bg-red-700 transition-colors duration-200">
                            Сохранить все недостающие СНИЛС
                        </button>
                    </div>
                </div>
            </div>

            <!-- БЛОК: ПРЕДУПРЕЖДЕНИЕ О НЕДОСТАЮЩИХ МПИ (Ключ - ГРСИ) -->
            <div id="missingMpiContainer" class="hidden p-4 bg-orange-100 border-l-4 border-orange-500 rounded-lg shadow-md">
                <div class="flex items-start">
                    <svg class="h-6 w-6 text-orange-600 mt-1 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h.01M17 11h.01M9 15h.01M15 15h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" /></svg>
                    <div class="ml-3 w-full">
                        <h3 class="text-lg font-semibold text-orange-800">
                            Обнаружены недостающие МПИ!
                        </h3>
                        <p class="mt-1 text-sm text-orange-700">
                            Введите Межповерочный Интервал (в месяцах) для следующих Номеров записи ГРСИ.
                        </p>
                        <!-- ДИНАМИЧЕСКАЯ ФОРМА ДЛЯ БЫСТРОГО ВВОДА МПИ -->
                        <form id="missingMpiForm" class="mt-2 text-sm bg-orange-50 p-3 rounded max-h-56 overflow-y-auto space-y-2">
                            <!-- Список типов СИ и полей ввода будет сгенерирован здесь -->
                        </form>
                        <button id="saveMissingMpiButton" class="w-full mt-3 bg-orange-600 text-white font-bold py-2 rounded-lg hover:bg-orange-700 transition-colors duration-200">
                            Сохранить все недостающие МПИ
                        </button>
                    </div>
                </div>
            </div>


            <!-- БЛОК 2: Статус и Скачивание -->
            <div class="p-4 bg-gray-50 rounded-lg shadow-inner border border-gray-200">
                <h2 class="text-xl font-semibold text-gray-700 mb-3 border-b pb-1">
                    Статус и результат
                </h2>
                
                <div id="statusMessage" class="text-gray-600 text-lg font-semibold mb-4">
                    Ожидание загрузки файла...
                </div>
                
                <!-- Processing Animation -->
                <div id="processingIndicator" class="mt-4 hidden">
                    <div class="h-2.5 bg-sky-200 rounded-full overflow-hidden">
                        <div class="h-full bg-accent-sky rounded-full animate-progress-stripes"></div>
                    </div>
                    <p class="text-xs text-accent-sky mt-1 font-medium animate-pulse">Обработка данных...</p>
                </div>

                <!-- Кнопка с accent-emerald -->
                <button id="downloadButton"
                        class="w-full mt-4 bg-emerald-500 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:bg-emerald-600 transition-colors duration-200 opacity-50 cursor-not-allowed disabled:shadow-none"
                        disabled>
                    Скачать XML-файл
                </button>
                <p id="recordCount" class="text-sm text-gray-500 mt-2 text-center hidden"></p>
            </div>
        </div>
        
        <!-- БЛОК 3: Управление сопоставлением Авторов и СНИЛС -->
        <details class="mt-8 p-4 bg-yellow-50 border border-yellow-300 rounded-lg" open>
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-yellow-800 focus:outline-none">
                <span>
                    <svg class="w-5 h-5 inline-block mr-2 text-yellow-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" /></svg>
                    Управление сотрудниками и СНИЛС (Обязательно!)
                </span>
                <svg class="w-4 h-4 text-yellow-600 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            
            <div class="mt-4 space-y-4">
                <form id="snilsMappingForm" class="flex flex-col sm:flex-row gap-2">
                    <input type="text" id="authorNameInput" placeholder="ФИО автора (как в CSV)" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-yellow-500 focus:border-yellow-500 text-sm" autocomplete="off">
                    <input type="text" id="snilsInput" placeholder="СНИЛС (11 цифр)" pattern="^\d{11}$" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-yellow-500 focus:border-yellow-500 text-sm" autocomplete="off">
                    <button type="submit" class="bg-yellow-600 text-white p-2 rounded-lg font-medium hover:bg-yellow-700 transition duration-150 flex-shrink-0">
                        Добавить/Обновить
                    </button>
                </form>

                <div id="mappingListContainer" class="max-h-60 overflow-y-auto border border-gray-300 rounded-lg shadow-inner">
                    <!-- Mappings will be rendered here -->
                    <p class="p-4 text-gray-500 text-sm italic" id="emptyMappingMessage">
                        Нет сохраненных сопоставлений. Используйте форму выше или импортируйте JSON.
                    </p>
                </div>
            </div>
        </details>
        
        <!-- БЛОК 4: Управление сопоставлением ГРСИ и МПИ (Ключ - ГРСИ) -->
        <details class="mt-4 p-4 bg-green-50 border border-green-300 rounded-lg" open>
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-green-800 focus:outline-none">
                <span>
                    <svg class="w-5 h-5 inline-block mr-2 text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    Управление ГРСИ и МПИ (Ключ: Номер записи ГРСИ)
                </span>
                <svg class="w-4 h-4 text-green-600 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            
            <div class="mt-4 space-y-4">
                <form id="mpiMappingForm" class="flex flex-col sm:flex-row gap-2">
                    <input type="text" id="instrumentTypeInput" placeholder="Номер записи ГРСИ (как в CSV, колонка 4)" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-green-500 focus:border-green-500 text-sm" autocomplete="off">
                    <input type="number" id="mpiMonthsConfigInput" placeholder="МПИ (месяцы, напр. 12, 24)" min="1" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-green-500 focus:border-green-500 text-sm" autocomplete="off">
                    <button type="submit" class="bg-green-600 text-white p-2 rounded-lg font-medium hover:bg-green-700 transition duration-150 flex-shrink-0">
                        Добавить/Обновить
                    </button>
                </form>

                <div id="mpiMappingListContainer" class="max-h-60 overflow-y-auto border border-gray-300 rounded-lg shadow-inner">
                    <!-- Mappings will be rendered here -->
                    <p class="p-4 text-gray-500 text-sm italic" id="emptyMpiMessage">
                        Нет сохраненных интервалов МПИ.
                    </p>
                </div>
            </div>
        </details>

        <!-- Debug Log Spoiler (Контейнер лога) -->
        <details class="mt-8 p-4 bg-gray-100 border border-gray-300 rounded-lg" id="debugLogSpoiler">
            <summary class="flex justify-between items-center cursor-pointer font-semibold text-gray-700 focus:outline-none">
                <span>
                    <!-- Новая иконка: Документ/Список -->
                    <svg class="w-5 h-5 inline-block mr-2 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2m-9 0V3a1 1 0 011-1h4a1 1 0 011 1v2M9 5h6m-6 4h6m-6 4h6m-6 4h6" />
                    </svg>
                    Лог конвертации / Отладка (Открыть для просмотра деталей процесса)
                </span>
                <svg class="w-4 h-4 text-gray-500 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
            </summary>
            <!-- Контейнер лога: p-2 для минимального, но достаточного отступа -->
            <div id="logDetails" class="mt-2 text-sm text-gray-700 overflow-auto h-40 bg-white p-2 rounded-lg border border-gray-200 shadow-inner">
                <!-- Log entries will appear here as structured HTML -->
            </div>
        </details>

        <!-- Footer Section with Copyright -->
        <footer class="mt-10 pt-6 border-t border-gray-200 text-center">
            <p class="text-xs text-gray-400">
                Разработано Службой испытаний, экспертизы и метрологии ГАУ ИНПЦ "Гормедтехника".
            </p>
        </footer>
    </div>

    <script>
        // --- КОНФИГУРАЦИЯ ---
        const SNILS_STORAGE_KEY = 'fgis_fsa_author_snils_map'; 
        const MPI_STORAGE_KEY = 'fgis_fsa_mpi_map_grsi'; // КЛЮЧ ДЛЯ МПИ (привязан к ГРСИ)
        const HEADER_SKIP_LINES = 2; 
        const MIN_PROCESSING_TIME = 1500; 

        const COL_INDEX = {
            'Author': 1,
            'Type': 3,      // Тип СИ (Используется для XML-тега TypeMeasuringInstrument)
            'GRSI': 4,      // НОВЫЙ КЛЮЧ: Номер записи ГРСИ
            'Date': 5,
            'Suitability': 9,
            'Document': 10
        };

        // --- ГЛОБАЛЬНЫЕ ХРАНИЛИЩА ---
        let errorCount = 0;
        let authorSnilsMap = {}; // ФИО -> СНИЛС
        let mpiMonthsMap = {};  // Номер ГРСИ -> МПИ (в месяцах)


        // --- ЭЛЕМЕНТЫ DOM ---
        const fileInput = document.getElementById('fileInput');
        const dropArea = document.getElementById('drop-area');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const statusMessage = document.getElementById('statusMessage');
        const downloadButton = document.getElementById('downloadButton');
        const recordCountElement = document.getElementById('recordCount');
        const processingIndicator = document.getElementById('processingIndicator');
        const debugLogSpoiler = document.getElementById('debugLogSpoiler');
        const logDetails = document.getElementById('logDetails');

        // Элементы для СНИЛС
        const snilsMappingForm = document.getElementById('snilsMappingForm');
        const authorNameInput = document.getElementById('authorNameInput');
        const snilsInput = document.getElementById('snilsInput');
        const mappingListContainer = document.getElementById('mappingListContainer');
        const emptyMappingMessage = document.getElementById('emptyMappingMessage');
        const missingAuthorsContainer = document.getElementById('missingAuthorsContainer');
        const missingSnilsForm = document.getElementById('missingSnilsForm');
        const saveMissingSnilsButton = document.getElementById('saveMissingSnilsButton');

        // Элементы для МПИ
        const mpiMappingForm = document.getElementById('mpiMappingForm');
        const instrumentTypeInput = document.getElementById('instrumentTypeInput'); // Используется для ввода ГРСИ
        const mpiMonthsConfigInput = document.getElementById('mpiMonthsConfigInput');
        const mpiMappingListContainer = document.getElementById('mpiMappingListContainer');
        const emptyMpiMessage = document.getElementById('emptyMpiMessage');
        const missingMpiContainer = document.getElementById('missingMpiContainer');
        const missingMpiForm = document.getElementById('missingMpiForm');
        const saveMissingMpiButton = document.getElementById('saveMissingMpiButton');


        // --- УТИЛИТЫ И ОБЩИЕ ФУНКЦИИ ---

        function startProcessing() {
            logDetails.innerHTML = ''; 
            errorCount = 0;
            statusMessage.textContent = 'Начало обработки файла...';
            statusMessage.classList.remove('text-red-600');
            statusMessage.classList.add('text-gray-600');
            processingIndicator.classList.remove('hidden');
            downloadButton.disabled = true;
            downloadButton.classList.add('opacity-50', 'cursor-not-allowed', 'disabled:shadow-none');
            downloadButton.classList.remove('bg-emerald-500', 'hover:bg-emerald-600');
            recordCountElement.classList.add('hidden');
            missingAuthorsContainer.classList.add('hidden'); 
            missingMpiContainer.classList.add('hidden'); // Скрываем предупреждение о недостающих МПИ
        }

        function stopProcessing() {
            processingIndicator.classList.add('hidden');
            if (errorCount > 0) {
                 debugLogSpoiler.open = true; 
            }
        }

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.className = `font-semibold text-lg mb-4 ${isError ? 'text-red-600' : 'text-gray-600'}`;
            if (isError) {
                downloadButton.disabled = true;
                downloadButton.classList.add('opacity-50', 'cursor-not-allowed', 'disabled:shadow-none');
                downloadButton.classList.remove('bg-emerald-500', 'hover:bg-emerald-600');
            }
        }

        function updateSuccess(count) {
            updateStatus('Конвертация успешно завершена. Файл готов к скачиванию.', false);
            downloadButton.disabled = false;
            downloadButton.classList.remove('opacity-50', 'cursor-not-allowed', 'disabled:shadow-none');
            downloadButton.classList.add('bg-emerald-500', 'hover:bg-emerald-600');
            recordCountElement.textContent = `Сконвертировано записей: ${count}. Ошибок обработки строк: ${errorCount}.`;
            recordCountElement.classList.remove('hidden');
        }
        
        function logMessage(message, level = 'INFO') {
            const timestamp = new Date().toLocaleTimeString('ru-RU');
            
            let iconSvg = '';
            let textColor = 'text-gray-700';
            let levelColor = 'text-emerald-600'; 
            let levelDisplay = 'ИНФО';

            if (level === 'ERROR') {
                iconSvg = '<svg class="w-4 h-4 mr-1 flex-shrink-0 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.3 16c-.77 1.333.192 3 1.732 3z" /></svg>';
                textColor = 'text-red-700';
                levelColor = 'text-red-600';
                levelDisplay = 'ОШИБКА';
            } else if (level === 'WARN') {
                iconSvg = '<svg class="w-4 h-4 mr-1 flex-shrink-0 text-orange-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.3 16c-.77 1.333.192 3 1.732 3z" /></svg>';
                textColor = 'text-orange-700';
                levelColor = 'text-orange-600';
                levelDisplay = 'ПРЕДУПРЕЖДЕНИЕ';
            } else {
                iconSvg = '<svg class="w-4 h-4 mr-1 flex-shrink-0 text-emerald-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>';
            }

            const logEntryHtml = `
                <div class="flex items-start text-xs font-mono py-0 leading-snug">
                    ${iconSvg}
                    <span class="${levelColor} font-bold flex-shrink-0">[${timestamp}] [${levelDisplay}]:&nbsp;</span><span class="${textColor} break-words min-w-0 flex-1">${message}</span>
                </div>
            `;
            
            logDetails.innerHTML += logEntryHtml;
            logDetails.scrollTop = logDetails.scrollHeight; 
        }

        function logError(message) {
            logMessage(message, 'ERROR');
            errorCount++;
        }
        
        function hasEncodingIssues(text) {
            return text.includes('\uFFFD');
        }

        function detectDelimiter(headerLine) {
            const commaCount = (headerLine.match(/,/g) || []).length;
            const semicolonCount = (headerLine.match(/;/g) || []).length;

            if (semicolonCount > commaCount + 2) {
                return ';';
            }
            return ',';
        }

        function parseDate(dateStr) {
            const formats = ["YYYY-MM-DD", "DD.MM.YYYY", "DD-MM-YYYY"];
            const cleanDateStr = dateStr.trim().split(' ')[0];

            for (const format of formats) {
                const parts = cleanDateStr.match(/(\d+)/g); 
                
                if (parts && parts.length === 3) {
                    let year, month, day;

                    if (format === "YYYY-MM-DD") {
                        [year, month, day] = parts.map(Number);
                    } else { 
                        [day, month, year] = parts.map(Number);
                    }

                    // Используем T00:00:00, чтобы избежать проблем с часовыми поясами
                    const dateObj = new Date(year, month - 1, day);

                    if (dateObj.getFullYear() === year && dateObj.getMonth() === month - 1 && dateObj.getDate() === day) {
                        return dateObj;
                    }
                }
            }
            return null; 
        }

        function formatDateToISO(dateStr) {
            const dt = parseDate(dateStr);
            if (!dt) return ""; 

            const y = dt.getFullYear();
            const m = String(dt.getMonth() + 1).padStart(2, '0');
            const d = String(dt.getDate()).padStart(2, '0');
            
            return `${y}-${m}-${d}`;
        }


        /**
         * Функция расчета даты окончания поверки
         * Formula: DateVerification + MPI_Months - 1 day
         */
        function calculateDateEndVerification(dateVerificationStr, mpiMonths) {
            const dtStart = parseDate(dateVerificationStr);
            
            if (!dtStart) return ""; 

            const months = parseInt(mpiMonths, 10);
            if (isNaN(months) || months <= 0) {
                return "";
            }

            // Создаем копию даты для расчетов. Добавляем T00:00:00, чтобы сохранить локальную дату.
            const mpiDate = new Date(dtStart.getFullYear(), dtStart.getMonth(), dtStart.getDate());
            
            // 1. Добавляем количество месяцев МПИ
            mpiDate.setMonth(mpiDate.getMonth() + months);

            // 2. Вычитаем 1 день
            mpiDate.setDate(mpiDate.getDate() - 1);

            const y = mpiDate.getFullYear();
            const m = String(mpiDate.getMonth() + 1).padStart(2, '0');
            const d = String(mpiDate.getDate()).padStart(2, '0');
            
            return `${y}-${m}-${d}`;
        }
        
        function mapSuitability(suitabilityText) {
            const text = suitabilityText.trim().toLowerCase();
            if (text === "да" || text === "yes" || text === "пригоден") {
                return '1';
            }
            if (text === "нет" || text === "no" || text === "не пригоден") {
                return '2';
            }
            logMessage(`Не удалось определить пригодность для текста: "${suitabilityText}". Установлено значение по умолчанию: "Да" (1).`, 'WARN');
            return '1'; 
        }

        function generateFileName() {
            const now = new Date();
            const y = String(now.getFullYear());
            const m = String(now.getMonth() + 1).padStart(2, '0');
            const d = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const mm = String(now.getMinutes()).padStart(2, '0');
            const ss = String(now.getSeconds()).padStart(2, '0');
            
            return `${y}${m}${d}_${hh}${mm}${ss}_fgis.xml`;
        }
        
        function parseCsvLine(line, delimiter) {
            if (!line.trim()) return [];
            
            const fields = [];
            let currentField = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === delimiter && !inQuotes) {
                    fields.push(currentField.trim().replace(/^"|"$/g, ''));
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            fields.push(currentField.trim().replace(/^"|"$/g, ''));

            while (fields.length > 0 && fields[fields.length - 1] === '') {
                fields.pop();
            }
            return fields;
        }

        // --- ЛОГИКА СОПОСТАВЛЕНИЙ ---

        function loadMappings() {
            try {
                const storedSnils = localStorage.getItem(SNILS_STORAGE_KEY);
                if (storedSnils) {
                    authorSnilsMap = JSON.parse(storedSnils);
                    logMessage('Сопоставления СНИЛС загружены.');
                }
                const storedMpi = localStorage.getItem(MPI_STORAGE_KEY);
                 if (storedMpi) {
                    mpiMonthsMap = JSON.parse(storedMpi);
                    logMessage('Сопоставления МПИ (ГРСИ) загружены.');
                }
            } catch(e) {
                logError(`Ошибка загрузки сопоставлений из localStorage: ${e.message}`);
                authorSnilsMap = {};
                mpiMonthsMap = {};
            }
            renderMappings();
            renderMpiMappings();
        }

        function saveAndRenderMappings() {
            try {
                localStorage.setItem(SNILS_STORAGE_KEY, JSON.stringify(authorSnilsMap));
                logMessage('Сопоставления СНИЛС сохранены.');
            } catch(e) {
                logError(`Ошибка сохранения сопоставлений СНИЛС: ${e.message}`);
            }
            renderMappings();
        }
        
        function saveAndRenderMpiMappings() {
            try {
                localStorage.setItem(MPI_STORAGE_KEY, JSON.stringify(mpiMonthsMap));
                logMessage('Сопоставления МПИ (ГРСИ) сохранены.');
            } catch(e) {
                logError(`Ошибка сохранения сопоставлений МПИ: ${e.message}`);
            }
            renderMpiMappings();
        }

        function renderMappings() {
            const authors = Object.keys(authorSnilsMap).sort();
            mappingListContainer.innerHTML = ''; 
            
            if (authors.length === 0) {
                mappingListContainer.appendChild(emptyMappingMessage);
                emptyMappingMessage.classList.remove('hidden');
                return;
            }

            emptyMappingMessage.classList.add('hidden');

            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-gray-200';
            table.innerHTML = `
                <thead class="bg-gray-200 sticky top-0">
                    <tr>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ФИО</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">СНИЛС</th>
                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Действие</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-100" id="mappingTableBody">
                </tbody>
            `;
            mappingListContainer.appendChild(table);
            const tbody = document.getElementById('mappingTableBody');

            authors.forEach(author => {
                const snils = authorSnilsMap[author];
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50 transition duration-100';
                tr.innerHTML = `
                    <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">${author}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500">${snils}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-right text-sm font-medium">
                        <button data-author="${author}" class="delete-snils-btn text-red-600 hover:text-red-900 transition duration-150">
                            Удалить
                        </button>
                    </td>
                `;
                tbody.appendChild(tr);
            });

            tbody.querySelectorAll('.delete-snils-btn').forEach(button => {
                button.addEventListener('click', handleDeleteMapping);
            });
        }
        
        function renderMpiMappings() {
            const grsiNumbers = Object.keys(mpiMonthsMap).sort();
            mpiMappingListContainer.innerHTML = ''; 
            
            if (grsiNumbers.length === 0) {
                mpiMappingListContainer.appendChild(emptyMpiMessage);
                emptyMpiMessage.classList.remove('hidden');
                return;
            }

            emptyMpiMessage.classList.add('hidden');

            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-gray-200';
            table.innerHTML = `
                <thead class="bg-gray-200 sticky top-0">
                    <tr>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Номер ГРСИ</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">МПИ (мес.)</th>
                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Действие</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-100" id="mpiMappingTableBody">
                </tbody>
            `;
            mpiMappingListContainer.appendChild(table);
            const tbody = document.getElementById('mpiMappingTableBody');

            grsiNumbers.forEach(grsi => {
                const mpi = mpiMonthsMap[grsi];
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50 transition duration-100';
                tr.innerHTML = `
                    <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">${grsi}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500">${mpi}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-right text-sm font-medium">
                        <button data-type="${grsi}" class="delete-mpi-btn text-red-600 hover:text-red-900 transition duration-150">
                            Удалить
                        </button>
                    </td>
                `;
                tbody.appendChild(tr);
            });

            tbody.querySelectorAll('.delete-mpi-btn').forEach(button => {
                button.addEventListener('click', handleDeleteMpiMapping);
            });
        }

        function handleMappingForm(e) {
            e.preventDefault();
            const author = authorNameInput.value.trim();
            const snils = snilsInput.value.trim();

            if (author && snils.match(/^\d{11}$/)) {
                authorSnilsMap[author] = snils;
                logMessage(`СНИЛС сопоставление добавлено/обновлено: ${author} -> ${snils}`);
                saveAndRenderMappings();
                authorNameInput.value = '';
                snilsInput.value = '';
            } else {
                 logError('Ошибка: Проверьте правильность ФИО автора и СНИЛС (11 цифр).');
            }
        }
        
        function handleMpiMappingForm(e) {
            e.preventDefault();
            const grsiNumber = instrumentTypeInput.value.trim(); // Номер ГРСИ
            const mpi = mpiMonthsConfigInput.value.trim();
            const mpiInt = parseInt(mpi, 10);

            if (grsiNumber && !isNaN(mpiInt) && mpiInt > 0) {
                mpiMonthsMap[grsiNumber] = mpiInt;
                logMessage(`МПИ сопоставление добавлено/обновлено: ГРСИ №${grsiNumber} -> ${mpiInt} мес.`);
                saveAndRenderMpiMappings();
                instrumentTypeInput.value = '';
                mpiMonthsConfigInput.value = '';
            } else {
                 logError('Ошибка: Проверьте правильность Номера ГРСИ и МПИ (должно быть целое число месяцев > 0).');
            }
        }

        function handleDeleteMapping(e) {
            const author = e.target.dataset.author;
            if (author in authorSnilsMap) {
                delete authorSnilsMap[author];
                logMessage(`Сопоставление СНИЛС удалено для автора: ${author}`);
                saveAndRenderMappings();
            }
        }
        
        function handleDeleteMpiMapping(e) {
            const grsi = e.target.dataset.type; // data-type содержит номер ГРСИ
            if (grsi in mpiMonthsMap) {
                delete mpiMonthsMap[grsi];
                logMessage(`Сопоставление МПИ удалено для ГРСИ №: ${grsi}`);
                saveAndRenderMpiMappings();
            }
        }
        
        // --- ЛОГИКА ПРОВЕРКИ НЕДОСТАЮЩИХ ДАННЫХ ---

        function getUniqueValuesFromCsv(csvContent, delimiter, colIndex) {
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            if (lines.length <= HEADER_SKIP_LINES + 1) return new Set();

            const dataLines = lines.slice(HEADER_SKIP_LINES + 1);
            const uniqueValues = new Set();
            
            dataLines.forEach((line) => {
                const fields = parseCsvLine(line, delimiter);
                if (fields.length > colIndex) {
                    const value = fields[colIndex].trim();
                    if (value) uniqueValues.add(value);
                }
            });
            return uniqueValues;
        }

        function checkAndDisplayMissingAuthors(uniqueAuthors) {
            const missingAuthors = [];
            uniqueAuthors.forEach(author => {
                if (!(author in authorSnilsMap)) {
                    missingAuthors.push(author);
                }
            });

            if (missingAuthors.length > 0) {
                missingAuthorsContainer.classList.remove('hidden');
                logError(`Обнаружено ${missingAuthors.length} уникальных авторов без сопоставления СНИЛС.`);
                
                missingSnilsForm.innerHTML = ''; 
                missingAuthors.forEach(author => {
                    const div = document.createElement('div');
                    div.className = 'flex flex-col sm:flex-row items-center gap-2 bg-white p-2 rounded shadow-sm border border-red-200';
                    div.innerHTML = `
                        <span class="font-medium text-gray-800 text-sm w-full sm:w-2/5 truncate" title="${author}">${author}</span>
                        <input type="text" data-author="${author}" placeholder="СНИЛС (11 цифр)" pattern="^\\d{11}$"
                               class="snils-input flex-1 p-1 border border-gray-300 rounded text-sm w-full" autocomplete="off">
                    `;
                    missingSnilsForm.appendChild(div);
                });
                saveMissingSnilsButton.onclick = handleMissingSnilsSubmission;
                return true; // Есть недостающие данные
            } else {
                missingAuthorsContainer.classList.add('hidden');
                logMessage('Все авторы из файла успешно сопоставлены с данными СНИЛС.');
                return false;
            }
        }
        
        function checkAndDisplayMissingMpi(csvContent, usedDelimiter) {
            // Используем COL_INDEX.GRSI для получения уникальных значений
            const uniqueGrsiNumbers = getUniqueValuesFromCsv(csvContent, usedDelimiter, COL_INDEX.GRSI);
            
            const missingGrsi = [];
            uniqueGrsiNumbers.forEach(grsi => {
                if (!(grsi in mpiMonthsMap)) {
                    missingGrsi.push(grsi);
                }
            });

            if (missingGrsi.length > 0) {
                missingMpiContainer.classList.remove('hidden');
                logError(`Обнаружено ${missingGrsi.length} уникальных номеров ГРСИ без сопоставления МПИ.`);
                
                missingMpiForm.innerHTML = ''; 
                missingGrsi.forEach(grsi => {
                    const div = document.createElement('div');
                    div.className = 'flex flex-col sm:flex-row items-center gap-2 bg-white p-2 rounded shadow-sm border border-orange-200';
                    div.innerHTML = `
                        <span class="font-medium text-gray-800 text-sm w-full sm:w-2/5 truncate" title="${grsi}">ГРСИ №: ${grsi}</span>
                        <input type="number" data-type="${grsi}" placeholder="МПИ (месяцы)" min="1"
                               class="mpi-input flex-1 p-1 border border-gray-300 rounded text-sm w-full" autocomplete="off">
                    `;
                    missingMpiForm.appendChild(div);
                });
                saveMissingMpiButton.onclick = handleMissingMpiSubmission;
                return true; // Есть недостающие данные
            } else {
                missingMpiContainer.classList.add('hidden');
                logMessage('Все номера ГРСИ из файла успешно сопоставлены с данными МПИ.');
                return false;
            }
        }

        /**
         * Обрабатывает форму пакетного ввода недостающих СНИЛС.
         */
        function handleMissingSnilsSubmission(e) {
            e.preventDefault();
            const inputs = missingSnilsForm.querySelectorAll('.snils-input');
            let newMappingsCount = 0;
            let errorFound = false;

            inputs.forEach(input => {
                const author = input.dataset.author;
                const snils = input.value.trim();

                input.classList.remove('border-red-500', 'bg-red-50', 'border-emerald-500', 'bg-emerald-50');
                
                if (snils.length > 0) {
                    if (snils.match(/^\d{11}$/)) {
                        if (!(author in authorSnilsMap) || authorSnilsMap[author] !== snils) {
                            authorSnilsMap[author] = snils;
                            newMappingsCount++;
                        }
                        input.classList.add('border-emerald-500', 'bg-emerald-50');
                        input.disabled = true; 
                    } else {
                        logError(`Некорректный СНИЛС для "${author}". Ожидается 11 цифр.`);
                        input.classList.add('border-red-500', 'bg-red-50');
                        errorFound = true;
                    }
                }
            });

            if (errorFound) {
                logMessage('Не все СНИЛС сохранены из-за ошибок валидации. Исправьте выделенные поля.', 'ERROR');
                return;
            }

            if (newMappingsCount > 0) {
                saveAndRenderMappings();
                logMessage(`Успешно добавлено/обновлено ${newMappingsCount} сопоставлений СНИЛС.`);
                updateStatus('Сопоставления СНИЛС обновлены. Перезагрузите CSV-файл для повторной конвертации.');
            } else {
                logMessage('Нет новых данных СНИЛС для сохранения.');
            }
            
            // Если все поля были успешно сохранены, скрыть блок.
            if (errorFound === false) {
                 missingAuthorsContainer.classList.add('hidden');
            }
        }
        
        /**
         * Обрабатывает форму пакетного ввода недостающих МПИ.
         */
        function handleMissingMpiSubmission(e) {
            e.preventDefault();
            const inputs = missingMpiForm.querySelectorAll('.mpi-input');
            let newMappingsCount = 0;
            let errorFound = false;

            inputs.forEach(input => {
                const grsiNumber = input.dataset.type; // data-type содержит номер ГРСИ
                const mpi = parseInt(input.value.trim(), 10);

                input.classList.remove('border-red-500', 'bg-red-50', 'border-emerald-500', 'bg-emerald-50');
                
                if (!isNaN(mpi)) {
                    if (mpi > 0) {
                        if (mpiMonthsMap[grsiNumber] !== mpi) {
                            mpiMonthsMap[grsiNumber] = mpi;
                            newMappingsCount++;
                        }
                        input.classList.add('border-emerald-500', 'bg-emerald-50');
                        input.disabled = true; 
                    } else {
                        logError(`Некорректный МПИ для ГРСИ №${grsiNumber}. Ожидается целое число месяцев > 0.`);
                        input.classList.add('border-red-500', 'bg-red-50');
                        errorFound = true;
                    }
                }
            });

            if (errorFound) {
                logMessage('Не все МПИ сохранены из-за ошибок валидации. Исправьте выделенные поля.', 'ERROR');
                return;
            }

            if (newMappingsCount > 0) {
                saveAndRenderMpiMappings();
                logMessage(`Успешно добавлено/обновлено ${newMappingsCount} сопоставлений МПИ.`);
                updateStatus('Сопоставления МПИ обновлены. Перезагрузите CSV-файл для повторной конвертации.');
            } else {
                logMessage('Нет новых данных МПИ для сохранения.');
            }
            
            // Если все поля были успешно сохранены, скрыть блок.
            if (errorFound === false) {
                 missingMpiContainer.classList.add('hidden');
            }
        }

        // --- ОСНОВНАЯ ЛОГИКА КОНВЕРТАЦИИ ---

        function convertToXML(csvContent, usedDelimiter) {
            logMessage('Начало процесса конвертации CSV в XML.');
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            
            if (lines.length <= HEADER_SKIP_LINES) {
                logError('Файл содержит недостаточно строк для обработки (<= 2).');
                return null;
            }

            const csvTextWithHeader = lines.slice(HEADER_SKIP_LINES);
            logMessage(`Пропущено ${HEADER_SKIP_LINES} строк метаданных. Общее количество строк для анализа: ${csvTextWithHeader.length}.`);
            
            if (csvTextWithHeader.length === 0) return null;

            const headerLine = csvTextWithHeader[0];
            const effectiveDelimiter = usedDelimiter || detectDelimiter(headerLine);
            logMessage(`Определен разделитель: "${effectiveDelimiter}".`);
            
            const dataLines = csvTextWithHeader.slice(1); 
            
            const dataRecords = dataLines.map((line) => {
                return parseCsvLine(line, effectiveDelimiter);
            }).filter(fields => fields.length > 0); 
            
            logMessage(`Найдено ${dataRecords.length} потенциальных строк для конвертации.`);

            if (dataRecords.length === 0) return null;

            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<Message xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="schema.xsd">\n';
            xml += '    <VerificationMeasuringInstrumentData>\n';
            
            let recordCount = 0;
            
            for (let i = 0; i < dataRecords.length; i++) {
                const fields = dataRecords[i];
                const lineNumber = i + HEADER_SKIP_LINES + 2; 

                // Проверка на минимальное количество колонок (документ - 10, ГРСИ - 4)
                if (fields.length < COL_INDEX.Document + 1 || fields.length < COL_INDEX.GRSI + 1) {
                     logError(`Строка ${lineNumber}: Пропущена: недостаточно столбцов.`);
                     continue;
                }

                try {
                    const authorFull = fields[COL_INDEX.Author].trim();
                    const typeInstrument = fields[COL_INDEX.Type].trim();     // Используется для XML-тега TypeMeasuringInstrument
                    const grsiNumber = fields[COL_INDEX.GRSI].trim();         // Используется как ключ для МПИ
                    const documentNum = fields[COL_INDEX.Document];
                    const dateVerification = fields[COL_INDEX.Date];
                    const suitabilityText = fields[COL_INDEX.Suitability];

                    if (!documentNum || documentNum.trim() === '') {
                        logError(`Строка ${lineNumber}: Пропущена, отсутствует номер документа (колонка ${COL_INDEX.Document}).`);
                        continue;
                    }
                    
                    // --- 1. Проверка СНИЛС ---
                    const snils = authorSnilsMap[authorFull];
                    if (!snils) {
                        logError(`Строка ${lineNumber} (${documentNum}): Отсутствует сопоставление СНИЛС для автора: "${authorFull}". (Запись пропущена)`);
                        continue;
                    }
                    
                    // --- 2. Проверка МПИ (по ключу ГРСИ) ---
                    const mpiMonths = mpiMonthsMap[grsiNumber];
                    if (!mpiMonths) {
                        logError(`Строка ${lineNumber} (${documentNum}): Отсутствует сопоставление МПИ для ГРСИ №: "${grsiNumber}". (Запись пропущена)`);
                        continue;
                    }


                    // --- Валидация и Форматирование ---
                    
                    const dateVerificationClean = dateVerification.split(' ')[0];
                    const formattedDateVerification = formatDateToISO(dateVerificationClean);
                    
                    if (formattedDateVerification === "") {
                         logError(`Строка ${lineNumber} (${documentNum}): Не удалось преобразовать дату "${dateVerificationClean}". (Запись пропущена)`);
                         continue;
                    }
                    
                    // Расчет даты окончания поверки с использованием МПИ (в месяцах)
                    const dateEndVerification = calculateDateEndVerification(dateVerificationClean, mpiMonths);
                    const resultVerification = mapSuitability(suitabilityText);
                    
                    // Разделение ФИО
                    const authorParts = authorFull.split(/\s+/).filter(p => p.length > 0);
                    const lastName = authorParts[0] || "Неизвестный";
                    const firstName = authorParts.slice(1).join(' ') || "Автор";
                    
                    // Экранирование XML-специальных символов
                    const escape = (str) => str ? str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;') : '';

                    xml += '        <VerificationMeasuringInstrument>\n';
                    xml += `            <NumberVerification>${escape(documentNum)}</NumberVerification>\n`;
                    xml += `            <DateVerification>${escape(formattedDateVerification)}</DateVerification>\n`;
                    
                    if (resultVerification === '1' && dateEndVerification) {
                        xml += `            <DateEndVerification>${escape(dateEndVerification)}</DateEndVerification>\n`;
                    } else if (resultVerification === '1' && !dateEndVerification) {
                        logError(`Строка ${lineNumber} (${documentNum}): Не удалось рассчитать DateEndVerification. Поле пропущено.`);
                    }
                    // TypeMeasuringInstrument берется из колонки 3 ('Type')
                    xml += `            <TypeMeasuringInstrument>${escape(typeInstrument)}</TypeMeasuringInstrument>\n`;
                    xml += '            <ApprovedEmployees>\n';
                    xml += '                <Name>\n';
                    xml += `                    <Last>${escape(lastName)}</Last>\n`;
                    xml += `                    <First>${escape(firstName)}</First>\n`;
                    xml += '                </Name>\n';
                    xml += `                <SNILS>${escape(snils)}</SNILS>\n`;
                    xml += '            </ApprovedEmployees>\n';
                    xml += `            <ResultVerification>${resultVerification}</ResultVerification>\n`;
                    xml += '        </VerificationMeasuringInstrument>\n';
                    
                    recordCount++;

                } catch (e) {
                    logError(`Строка ${lineNumber}: Критическая ошибка обработки: ${e.message}.`);
                }
            }
            
            logMessage(`Всего обработано валидных записей: ${recordCount}. Ошибок обработки: ${errorCount}.`);

            xml += '    </VerificationMeasuringInstrumentData>\n';
            xml += '    <SaveMethod>2</SaveMethod>\n';
            xml += '</Message>';

            if (recordCount > 0) {
                return xml;
            } else {
                return null;
            }
        }

        function downloadXML(xmlContent, filename) {
            const blob = new Blob([xmlContent], { type: 'text/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename; 
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logMessage(`XML-файл "${filename}" создан и загружен.`);
        }
        
        function readFileWithEncoding(file, encoding) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file, encoding);
            });
        }

        // --- ОБРАБОТЧИКИ СОБЫТИЙ ---

        async function handleFiles(files) {
            if (files.length === 0) return;

            const file = files[0];
            if (!file.name.toLowerCase().endsWith('.csv')) {
                updateStatus("Ошибка: Пожалуйста, выберите файл CSV.", true);
                logError(`Выбран не CSV файл: ${file.name}`);
                return;
            }

            fileNameDisplay.textContent = `Выбран файл: ${file.name}`;
            startProcessing();
            const startTime = performance.now();

            let csvContent = null;
            let finalXmlContent = null;
            let filename = '';
            let success = false;
            let errorMessage = '';

            try {
                // --- 1. Чтение файла ---
                logMessage('Чтение файла с автоопределением кодировки...');
                let content = await readFileWithEncoding(file, 'UTF-8');
                let usedDelimiter = null;
                
                if (hasEncodingIssues(content)) {
                    content = await readFileWithEncoding(file, 'windows-1251');
                    logMessage(`Файл успешно прочитан с использованием кодировки Windows-1251.`);
                } else {
                    logMessage('Файл успешно прочитан с кодировкой UTF-8.');
                }
                csvContent = content;
                usedDelimiter = detectDelimiter(csvContent.split('\n')[HEADER_SKIP_LINES]);
                
                // --- 2. Сбор уникальных данных ---
                const uniqueAuthors = getUniqueValuesFromCsv(csvContent, usedDelimiter, COL_INDEX.Author);

                // --- 3. Проверка недостающих данных ---
                const missingSnils = checkAndDisplayMissingAuthors(uniqueAuthors);
                const missingMpi = checkAndDisplayMissingMpi(csvContent, usedDelimiter); // Использует COL_INDEX.GRSI внутри
                
                if (missingSnils || missingMpi) {
                    errorMessage = "Требуется ввод недостающих данных (СНИЛС или МПИ). Исправьте выделенные блоки.";
                    logError(errorMessage);
                    return; // Прерываем конвертацию
                }
                
                // --- 4. Конвертация ---
                finalXmlContent = convertToXML(csvContent, usedDelimiter);

                if (finalXmlContent) {
                    filename = generateFileName();
                    success = true;
                } else {
                    errorMessage = "Ошибка: Не найдено валидных записей для конвертации. Проверьте лог отладки.";
                    logError(errorMessage);
                }

            } catch(e) {
                 errorMessage = `Критическая ошибка чтения или обработки файла: ${e.message}`;
                 logError(`КРИТИЧЕСКАЯ ОШИБКА: ${e.message}`);
            }

            // --- 5. Завершение ---
            const elapsedTime = performance.now() - startTime;
            const delay = Math.max(0, MIN_PROCESSING_TIME - elapsedTime);

            setTimeout(() => {
                stopProcessing();
                
                if (success) {
                    const recordCount = (finalXmlContent.match(/<VerificationMeasuringInstrument>/g) || []).length; 
                    updateSuccess(recordCount);
                    downloadButton.onclick = () => downloadXML(finalXmlContent, filename);
                } else {
                    updateStatus(errorMessage, true);
                }
            }, delay);
        }

        // Drop Area Events
        dropArea.addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
            e.target.value = null; 
        });

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('active'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('active'), false);
        });

        dropArea.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }, false);

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // --- Прикрепление обработчиков форм ---
        snilsMappingForm.addEventListener('submit', handleMappingForm);
        mpiMappingForm.addEventListener('submit', handleMpiMappingForm);

        // Инициализация
        loadMappings(); // Загрузка сохраненных сопоставлений СНИЛС и МПИ
        updateStatus("Готов к работе. Поддерживается автоопределение кодировки.");
    </script>
</body>
</html>
